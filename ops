{"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"ops":[{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1609602862,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc1MzQ4OTc1OQ==","github-url":"https://github.com/rurban/smhasher/issues/177#issuecomment-753489759"},"nonce":"yZnhRsSv2AAAd/3xSSaofsdu4/w=","message":"\u003e the problem of wyhash is that it has no problem ;-)\n\nWell, maybe, as you wish. Anyway, it's not usable for file hashing in its current form. Strangely enough, Reini Urban advertises fast hash functions as useful for file hashing without even checking if they have the necessary interface.","files":null},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1609671154,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc1MzU5OTA0Mg==","github-url":"https://github.com/rurban/smhasher/issues/177#issuecomment-753599042"},"nonce":"4PMFYRe0p+fd74GBlWkAZKzt+V0=","message":"I'm closing this topic. Sorry for disturbance. Maybe 128-bit multiplication does allow to mix two 64-bit messages, need to do more tests.","files":null},{"type":4,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1609671154,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50NDE2MjM1NDI2Ng=="},"nonce":"mCHlTRc8m+iKTrmtVvpeNdasDcA=","status":2},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1609776225,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc1NDA2MTQxMQ==","github-url":"https://github.com/rurban/smhasher/issues/177#issuecomment-754061411"},"nonce":"RT1yOtbiWliB6E+SwaCti0VpmSA=","message":"Anyway, from the point of view of \"message shuffling\", a construct like `m=A*B; return m^m\u003e\u003e64` used in wyhash is not ideal. You may compare it to my inner shuffler which produces an ideal remapping without holes. For certain, if 2 message words will be shuffled, it will be a complete loss of information.\n```\n#include \u003cstdio.h\u003e\n#include \u003cstdint.h\u003e\n\nconst int shuf_bits = 10;\nconst int shuf = 1 \u003c\u003c shuf_bits;\nconst int mask = shuf - 1;\n\nuint32_t mulfn( uint32_t Seed, uint32_t Seed2, uint32_t m )\n{\n/*\tSeed2 ^= m;\n\tSeed += Seed2;\n\tSeed \u0026= mask;\n\tSeed *= ( Seed2 - ~Seed2 ) \u0026 mask;\n*/\n\tuint32_t mv = Seed ^ m;\n\tmv *= Seed2;\n\tSeed = mv ^ mv \u003e\u003e shuf_bits;\n\n\treturn( Seed \u0026 mask );\n}\n\nint main()\n{\n\tuint64_t HitCount = 0;\n\tuint32_t Seed;\n\tuint32_t Seed2;\n\tuint32_t m;\n\n\tfor( Seed = 0; Seed \u003c shuf; Seed++ )\n\t{\n\t\tfor( Seed2 = 0; Seed2 \u003c shuf; Seed2++ )\n\t\t{\n\t\t\tuint8_t HitBuf[ shuf ] = { 0 };\n\n\t\t\tfor( m = 0; m \u003c shuf; m++ )\n\t\t\t{\n\t\t\t\tuint32_t v = mulfn( Seed, Seed2, m );\n\n\t\t\t\tif( HitBuf[ v ] == 0 )\n\t\t\t\t{\n\t\t\t\t\tHitBuf[ v ] = 1;\n\t\t\t\t\tHitCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf( \"Hits: %llu/%llu\\n\", HitCount, (uint64_t) shuf * shuf * shuf );\n}\n```","files":null}]}