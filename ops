{"author":{"id":"778d0d8adcf381faef152a6577de9902e431612075f7585af0b6ac9d7d1c1475"},"ops":[{"type":3,"author":{"id":"778d0d8adcf381faef152a6577de9902e431612075f7585af0b6ac9d7d1c1475"},"timestamp":1574174734,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU1NTUzOTc4NQ==","github-url":"https://github.com/rurban/smhasher/issues/76#issuecomment-555539785"},"nonce":"6fl59NI8z3c9U1TLn8g3hNs5G2A=","message":"\u003e \n\u003e \n\u003e Reini,\n\u003e please consider removing the old ones: 'FNV1a_YT' and 'FNV1A_Totenschiff'.\n\u003e My wish is to see the latest and strongest, only, which is 'FNV1A_Pippip_Yurii', at:\n\u003e https://www.codeproject.com/Articles/716530/Fastest-Hash-Function-for-Table-Lookups-in-C\n\u003e \n\u003e @dumblob\n\u003e Sure, but I still have no framework - just random benchmarks, very informative, though. It would be nice to gather the scattered speed and collision benchmarks into one package...\n\u003e \n\u003e At the moment, had time to run only Yann's speed benchmark v0.7.2 on my i5-7200U:\n\u003e \n\u003e I added to 'hashes.h':\n\u003e \n\u003e ```\n\u003e #include \"wyhash.h\"\n\u003e \n\u003e // Kaze was here\n\u003e #include \u003cstdint.h\u003e // uint8_t needed\n\u003e #define _PADr_KAZE(x, n) ( ((x) \u003c\u003c (n))\u003e\u003e(n) )\n\u003e // Many thanks go to Yurii 'Hordi' Hordiienko, he lessened with 3 instructions the original 'Pippip', thus:\n\u003e //#include \u003cstdlib.h\u003e\n\u003e //#include \u003cstdint.h\u003e\n\u003e uint32_t FNV1A_Pippip_Yurii(const char *str, size_t wrdlen) {\n\u003e \tconst uint32_t PRIME = 591798841; uint32_t hash32; uint64_t hash64 = 14695981039346656037;\n\u003e \tsize_t Cycles, NDhead;\n\u003e if (wrdlen \u003e 8) {\n\u003e \tCycles = ((wrdlen - 1)\u003e\u003e4) + 1; NDhead = wrdlen - (Cycles\u003c\u003c3);\n\u003e         for(; Cycles--; str += 8) {\n\u003e \t\thash64 = ( hash64 ^ (*(uint64_t *)(str)) ) * PRIME;        \n\u003e \t\thash64 = ( hash64 ^ (*(uint64_t *)(str+NDhead)) ) * PRIME;        \n\u003e \t}\n\u003e } else\n\u003e \thash64 = ( hash64 ^ _PADr_KAZE(*(uint64_t *)(str+0), (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n\u003e hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32)); return hash32 ^ (hash32 \u003e\u003e 16);\n\u003e } // Last update: 2019-Oct-30, 14 C lines strong, Kaze.\n\u003e \n\u003e size_t FNV1A_Pippip_Yurii_wrapper(const void* src, size_t srcSize, void* dst, size_t dstCapacity, void* customPayload)\n\u003e {\n\u003e     (void)dst; (void)dstCapacity; (void)customPayload;\n\u003e     return (size_t) FNV1A_Pippip_Yurii(src, srcSize);\n\u003e }\n\u003e \n\u003e size_t wyhash_wrapper(const void* src, size_t srcSize, void* dst, size_t dstCapacity, void* customPayload)\n\u003e {\n\u003e     (void)dst; (void)dstCapacity; (void)customPayload;\n\u003e     return (size_t) wyhash(src, srcSize, 0);\n\u003e }\n\u003e ```\n\u003e \n\u003e By the way, if anyone has machine with 32GB then we all can witness one superb benchmark - Lookuperorama (featuring WYHASHv3 and XXH3) testing CIHAI - 'Sea of Words', the treasure of Chinese language 22,000,000 hieroglyphs strong. Just let me know, will share the package.\n\u003e \n\u003e And, could someone explain why the big difference between different metrics:\n\u003e \n\u003e ```\n\u003e key size            wyhash    XXH_SCALAR\n\u003e small:cycles/hash   13.070    18.293\n\u003e ```\n\u003e \n\u003e and\n\u003e https://software.intel.com/en-us/forums/intel-moderncode-for-parallel-architectures/topic/824947#comment-1947447\n\u003e \n\u003e As always, the attached .ZIP package contains the sources, binary, MAKE.EXE.BAT and RUNME.BAT, don't know how most powerful Zen and Xeon processors run it!\n\nDear @Sanmayce  and @dumblob :\nxxh3's benchmark suite has problem. it make use of \"deep hided\" function pointers, preventing function inlining. Thus wyhash is biased to low speed/throughput. By direct calling wyhash, it is faster than xxh3 and close to FNV1A_Pippip_Yurii","files":null},{"type":3,"author":{"id":"778d0d8adcf381faef152a6577de9902e431612075f7585af0b6ac9d7d1c1475"},"timestamp":1574175268,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU1NTU0Mzg1NQ==","github-url":"https://github.com/rurban/smhasher/issues/76#issuecomment-555543855"},"nonce":"BomThuM+bCwaoOGuTRjNyU3wWN4=","message":"===  benchmarking 1 hash functions  === \nbenchmarking large inputs : from 2 bytes (log1) to 0 MB (log16) \nxxh3   ,    481.2,   1017.8,   2141.4,   4028.1,   6333.3,   8123.4,   9959.9,  11217.2,  11740.3,  12523.5,  13236.9,  13338.9,  13211.9,  13510.9,  13707.8,  13247.8\nwyhash ,    491.4,   1020.7,   1971.3,   4100.3,   6390.7,   8097.7,   9717.4,  11334.5,  11747.4,  12537.3,  13274.3,  13410.8,  13501.1,  13642.7,  13625.2,  13716.4\nThroughput small inputs of fixed size : \nxxh3   ,252472924.1,244478888.7,242958679.5,256646691.8,242850450.4,243422152.4,267134693.5,241295393.0,266013827.0,256621626.7,265550781.8,256436657.2,255817293.9,254605804.1,255509272.5,256739032.9,206744767.0,207618907.3,208854543.0,223506731.6,207680637.9,207346241.8,208020523.1,207180096.0,202763424.6,200420327.5,203696985.2,192934690.7,190181735.5,190309117.2,189077593.8,209240186.6\nwyhash ,251285994.1,241975828.1,251142068.6,266731544.4,250203378.6,239772286.1,255990518.4,238556260.5,251418261.3,255869800.5,255892908.5,267203602.0,266752600.3,266271889.9,264580779.1,279111640.9,213632030.5,222942154.4,212368559.5,214331787.7,213844687.4,205285500.3,211776897.1,198377957.1,215640432.7,200200225.4,208590843.4,217882595.6,201857928.7,201157307.9,199333531.9,201881135.7\nbenchmarking random size inputs [1-N] : \nxxh3   ,244612418.5,253095975.2,242714125.5,245474823.3,247884068.1,249360562.1,258267797.5,249724514.7,260616655.3,251054864.7,251129489.5,251611725.7,251580566.5,263433966.7,251764336.9,254662134.1,249562665.1,240976748.2,236094564.3,242837613.5,230492290.8,223878876.4,244143672.0,236488612.7,241479809.8,234505027.5,232209808.3,230409901.0,231436613.4,230831157.9,227286565.5,235128399.6\nwyhash ,253929768.8,243180368.9,251852350.8,245799858.2,233914565.5,247838432.3,234348948.1,237269449.3,236975099.3,237253269.1,242521862.0,249299888.9,252971728.7,250136277.3,251350223.8,251972135.8,258476895.0,247761246.9,253247888.1,242959680.4,249576299.7,243513564.1,232753261.0,236895677.3,236046838.0,239651053.0,223734404.4,247204785.3,248768072.8,217470905.1,213205736.4,235779025.1\nLatency for small inputs of fixed size : \nxxh3   ,244417422.7,252460992.4,243636112.7,265806042.7,265666512.3,255441658.9,249257015.8,264220005.0,239148711.7,240251256.3,256421455.2,255668240.9,264229954.0,255418257.1,265081456.2,256344026.4,221476428.5,208001224.4,214777006.6,207204815.0,219542001.0,207447411.4,204950798.6,214475953.7,200812326.9,201887534.0,190671575.6,194939607.8,189328245.4,206607762.5,198458095.0,193502893.5\nwyhash ,241310546.6,239528874.8,244039279.0,263095441.0,254324701.1,257883448.5,263712675.6,256518866.4,265163752.6,264241385.4,254829557.2,262312031.8,239451377.4,239089309.6,239231105.8,254162534.3,213311310.6,207944744.8,211981394.4,201903228.6,207537744.6,205329503.6,206689325.1,214094187.4,207445436.3,202866749.2,201870597.4,202305220.6,202193016.6,202566848.7,208903061.5,202991655.0\nLatency for small inputs of random size [1-N] : \nxxh3   ,229627986.9,249688523.6,254040020.0,244612900.5,241851899.9,257150590.4,259465796.8,251717893.8,245926946.3,252185818.0,251170319.3,252590009.2,251679111.0,251198791.5,218292918.7,271232457.9,248534420.2,234109602.5,234525428.4,228919748.3,248525441.1,227150975.9,247746504.5,237928279.3,239655473.4,236842609.7,238186454.4,239894092.9,230006239.8,230065195.6,228760606.4,224782846.9\nwyhash ,251137977.5,251164545.9,220415605.3,236133775.5,247284809.7,248864960.2,260075623.1,249768153.4,257924132.4,259468464.0,254440450.8,253599406.2,260978621.1,238845775.7,255276423.1,262985606.0,257781540.5,246748348.4,246259477.0,198265912.4,233254684.2,245283818.7,220653442.9,220488664.8,237229308.3,219487549.6,239201753.1,229282661.6,235700358.0,225787527.1,228407403.9,232648920.2","files":null}]}