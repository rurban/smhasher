{"author":{"id":"0e0db9efebe974bb97e4ff793b33a8bef9e0a4bb09833c866802a945dd9f453a"},"ops":[{"type":3,"timestamp":1686585839,"metadata":{"github-id":"IC_kwDOARWYbc5eoVYT","github-url":"https://github.com/rurban/smhasher/issues/114#issuecomment-1587631635"},"nonce":"Dol8maHYrPrx2CBrdVV+a//zhew=","message":"This isn't fixed. I'm still getting sporadic failures with 2 collisions on a universal hash function:\n\n```\nTesting collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)\nTesting collisions (high 32-bit) - Expected          0.3, actual      0 (0.00x)\nTesting collisions (high 19-25 bits) - Worst is 24 bits: 78/76 (1.02x)\nTesting collisions (low  32-bit) - Expected          0.3, actual      2 (6.70x) (2) !!!!!\nTesting collisions (low  19-25 bits) - Worst is 23 bits: 169/152 (1.11x)\nTesting distribution - Worst bias is the 13-bit window at bit 55 - 0.605%\n```\n\nThis is not reasonable. Let's assume we have a perfect random oracle that outputs a completely uniform and random 32-bit value for each input. We are hashing 50643 inputs. I can simulate this by using a cryptographically secure PRNG in Rust by generating 50643 random indices and filling those:\n\n```rust\nuse rand::prelude::*;\nuse rand_chacha::ChaCha20Rng;\n\nfn sim_collisions\u003cR: Rng\u003e(w: usize, k: usize, rng: \u0026mut R) -\u003e usize {\n    let mut table = vec![0u8; 1 \u003c\u003c w];\n    let mut collisions = 0usize;\n    let mask = (1 \u003c\u003c w) - 1;\n    for _ in 0..k {\n        let i = rng.gen::\u003cusize\u003e() \u0026 mask;\n        collisions += table[i] as usize;\n        table[i] = 1;\n    }\n    return collisions;\n}\n\nfn main() {\n    let mut rng = ChaCha20Rng::seed_from_u64(0xdeadbeef);\n    let k = 50643;\n    let mut distribution = vec![0; k+1];\n    for _ in 0..1000 {\n        distribution[sim_collisions(32, k, \u0026mut rng)] += 1;\n    }\n    for c in 0..=k {\n        if distribution[c] \u003e 0 {\n            println!(\"{c} collisions: {}\", distribution[c]);\n        }\n    }\n}\n```\n\nHere are the results:\n\n```\n0 collisions: 719\n1 collisions: 241\n2 collisions: 38\n3 collisions: 2\n```\n\nThat's right, even an absolutely perfect random oracle fails this test ~40/1000 times. And you repeat this test for both the upper and lower 32-bits, so that's a 1 - (1 - 0.04)^2 = ~7.8% chance of failing this test, even if you're literally a perfect random oracle!","files":null},{"type":6,"timestamp":1686585914,"metadata":{"github-id":"UCE_lALOARWYbc5eoVYTzjKn-Ag"},"nonce":"nTp0aAhYabqW8zpKQ/DvFbMefKo=","target":"6a043c23cc085aa9db6a759533d2f72b5bc427f7884b06f0378986da196c609b","message":"This isn't fixed. I'm still getting sporadic failures with 2 collisions on a universal hash function:\n\n```\nKeyset 'Sparse' - 16-bit keys with up to 9 bits set - 50643 keys\nTesting collisions ( 64-bit) - Expected    0.0, actual      0 (0.00x)\nTesting collisions (high 32-bit) - Expected          0.3, actual      0 (0.00x)\nTesting collisions (high 19-25 bits) - Worst is 24 bits: 78/76 (1.02x)\nTesting collisions (low  32-bit) - Expected          0.3, actual      2 (6.70x) (2) !!!!!\nTesting collisions (low  19-25 bits) - Worst is 23 bits: 169/152 (1.11x)\nTesting distribution - Worst bias is the 13-bit window at bit 55 - 0.605%\n```\n\nThis is not reasonable. Let's assume we have a perfect random oracle that outputs a completely uniform and random 32-bit value for each input. We are hashing 50643 inputs. I can simulate this by using a cryptographically secure PRNG in Rust by generating 50643 random indices and filling those:\n\n```rust\nuse rand::prelude::*;\nuse rand_chacha::ChaCha20Rng;\n\nfn sim_collisions\u003cR: Rng\u003e(w: usize, k: usize, rng: \u0026mut R) -\u003e usize {\n    let mut table = vec![0u8; 1 \u003c\u003c w];\n    let mut collisions = 0usize;\n    let mask = (1 \u003c\u003c w) - 1;\n    for _ in 0..k {\n        let i = rng.gen::\u003cusize\u003e() \u0026 mask;\n        collisions += table[i] as usize;\n        table[i] = 1;\n    }\n    return collisions;\n}\n\nfn main() {\n    let mut rng = ChaCha20Rng::seed_from_u64(0xdeadbeef);\n    let k = 50643;\n    let mut distribution = vec![0; k+1];\n    for _ in 0..1000 {\n        distribution[sim_collisions(32, k, \u0026mut rng)] += 1;\n    }\n    for c in 0..=k {\n        if distribution[c] \u003e 0 {\n            println!(\"{c} collisions: {}\", distribution[c]);\n        }\n    }\n}\n```\n\nHere are the results:\n\n```\n0 collisions: 719\n1 collisions: 241\n2 collisions: 38\n3 collisions: 2\n```\n\nThat's right, even an absolutely perfect random oracle fails this test ~40/1000 times. And you repeat this test for both the upper and lower 32-bits, so that's a 1 - (1 - 0.04)^2 = ~7.8% chance of failing this test, even if you're literally a perfect random oracle!","files":null},{"type":3,"timestamp":1686586482,"metadata":{"github-id":"IC_kwDOARWYbc5eoZ7n","github-url":"https://github.com/rurban/smhasher/issues/114#issuecomment-1587650279"},"nonce":"WahhZiFFsHSxuxKTNTBc8eQBnzk=","message":"In case you don't trust `ChaCha20` I repeated the experiment with AES as the CSPRNG and got the following results:\n\n```\n0 collisions: 732\n1 collisions: 229\n2 collisions: 35\n3 collisions: 4\n```","files":null}]}