{"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"ops":[{"type":3,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572452921,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU0Nzk5NDA4Mg==","github-url":"https://github.com/rurban/smhasher/issues/75#issuecomment-547994082"},"nonce":"HckX71zQirSEmrF8yTwIBPl0CkY=","message":"This is lightly modified version, actually - attempt to add some parallel CPU instruction processing. Not sure about key distribution and final code performance but in any way...\n\n`uint32_t Hash_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint32_t hash32 = 2166136261;\n    unsigned long long hash64 = 14695981039346656037;//2166136261;\n    unsigned long long hash64_1 = 14695981039346656037;//2166136261;\n    size_t Cycles, NDhead;\n\n    if (wrdlen \u003e8) {\n        Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        NDhead = wrdlen - (Cycles\u003c\u003c3);\n\n        for(; Cycles--; str += 8) {\n            hash64 = ( hash64 ^ (*(long long *)(str)) ) * PRIME;\n            hash64_1 = ( hash64_1 ^ (*(long long *)(str+NDhead)) ) * PRIME;\n        }\n        hash64 = (hash64 ^ hash64_1) * PRIME;\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(long long *)str, (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n\n    hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n`\n\n`\nHash_Pippip(char const*, unsigned long):\n        mov     rax, QWORD PTR [rdi]\n        cmp     rsi, 8\n        jbe     .L2\n        movabs  rdx, -3750763034362895579\n        lea     rax, [rsi-1]\n        shr     rax, 4\n        lea     rcx, [8+rax*8]\n        mov     rax, rdx\n        sub     rsi, rcx\n        add     rcx, rdi\n.L3:\n        xor     rax, QWORD PTR [rdi]\n        xor     rdx, QWORD PTR [rdi+rsi]\n        add     rdi, 8\n        imul    rax, rax, 591798841\n        imul    rdx, rdx, 591798841\n        cmp     rdi, rcx\n        jne     .L3\n.L6:\n        xor     rax, rdx\n        imul    rax, rax, 591798841\n        mov     rdx, rax\n        shr     rdx, 32\n        xor     eax, edx\n        mov     edx, eax\n        shr     edx, 16\n        xor     eax, edx\n        ret\n.L2:\n        movabs  rdx, -3750763034362895579\n        mov     ecx, 8\n        sub     ecx, esi\n        sal     ecx, 3\n        sal     rax, cl\n        sar     rax, cl\n        jmp     .L6\n`","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572452953,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMwMTI0NDMxNA=="},"nonce":"Vn0DAXn6wzx21m+AdTqA+I6OFgM=","target":"2d2f7897e6d4c05d1b159cf1befe8f1eaab111a4077516ab695d0e978161409c","message":"This is lightly modified version, actually - attempt to add some parallel CPU instruction processing. Not sure about key distribution and final code performance but in any way...\n\n`uint32_t Hash_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint32_t hash32 = 2166136261;\n    unsigned long long hash64 = 14695981039346656037;//2166136261;\n    unsigned long long hash64_1 = 14695981039346656037;//2166136261;\n    size_t Cycles, NDhead;\n\n    if (wrdlen \u003e8) {\n        Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        NDhead = wrdlen - (Cycles\u003c\u003c3);\n\n        for(; Cycles--; str += 8) {\n            hash64 = ( hash64 ^ (*(long long *)(str)) ) * PRIME;\n            hash64_1 = ( hash64_1 ^ (*(long long *)(str+NDhead)) ) * PRIME;\n        }\n        hash64 = (hash64 ^ hash64_1) * PRIME;\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(long long *)str, (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n\n    hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n`\n`Hash_Pippip(char const*, unsigned long):\n        mov     rax, QWORD PTR [rdi]\n        cmp     rsi, 8\n        jbe     .L2\n        movabs  rdx, -3750763034362895579\n        lea     rax, [rsi-1]\n        shr     rax, 4\n        lea     rcx, [8+rax*8]\n        mov     rax, rdx\n        sub     rsi, rcx\n        add     rcx, rdi\n.L3:\n        xor     rax, QWORD PTR [rdi]\n        xor     rdx, QWORD PTR [rdi+rsi]\n        add     rdi, 8\n        imul    rax, rax, 591798841\n        imul    rdx, rdx, 591798841\n        cmp     rdi, rcx\n        jne     .L3\n.L6:\n        xor     rax, rdx\n        imul    rax, rax, 591798841\n        mov     rdx, rax\n        shr     rdx, 32\n        xor     eax, edx\n        mov     edx, eax\n        shr     edx, 16\n        xor     eax, edx\n        ret\n.L2:\n        movabs  rdx, -3750763034362895579\n        mov     ecx, 8\n        sub     ecx, esi\n        sal     ecx, 3\n        sal     rax, cl\n        sar     rax, cl\n        jmp     .L6`","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572453000,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMwMTI0NDg1NA=="},"nonce":"nOz/gqAVGuqtKJG4fBUSbFDY+kg=","target":"2d2f7897e6d4c05d1b159cf1befe8f1eaab111a4077516ab695d0e978161409c","message":"This is lightly modified version, actually - attempt to add some parallel CPU instruction processing. Not sure about key distribution and final code performance but in any way...\n\n`uint32_t Hash_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint32_t hash32 = 2166136261;\n    unsigned long long hash64 = 14695981039346656037;//2166136261;\n    unsigned long long hash64_1 = 14695981039346656037;//2166136261;\n    size_t Cycles, NDhead;\n\n    if (wrdlen \u003e8) {\n        Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        NDhead = wrdlen - (Cycles\u003c\u003c3);\n\n        for(; Cycles--; str += 8) {\n            hash64 = ( hash64 ^ (*(long long *)(str)) ) * PRIME;\n            hash64_1 = ( hash64_1 ^ (*(long long *)(str+NDhead)) ) * PRIME;\n        }\n        hash64 = (hash64 ^ hash64_1) * PRIME;\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(long long *)str, (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n\n    hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n`\n`\nHash_Pippip(char const*, unsigned long):\n        mov     rax, QWORD PTR [rdi]\n        cmp     rsi, 8\n        jbe     .L2\n        movabs  rdx, -3750763034362895579\n        lea     rax, [rsi-1]\n        shr     rax, 4\n        lea     rcx, [8+rax*8]\n        mov     rax, rdx\n        sub     rsi, rcx\n        add     rcx, rdi\n.L3:\n        xor     rax, QWORD PTR [rdi]\n        xor     rdx, QWORD PTR [rdi+rsi]\n        add     rdi, 8\n        imul    rax, rax, 591798841\n        imul    rdx, rdx, 591798841\n        cmp     rdi, rcx\n        jne     .L3\n.L6:\n        xor     rax, rdx\n        imul    rax, rax, 591798841\n        mov     rdx, rax\n        shr     rdx, 32\n        xor     eax, edx\n        mov     edx, eax\n        shr     edx, 16\n        xor     eax, edx\n        ret\n.L2:\n        movabs  rdx, -3750763034362895579\n        mov     ecx, 8\n        sub     ecx, esi\n        sal     ecx, 3\n        sal     rax, cl\n        sar     rax, cl\n        jmp     .L6`","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572453019,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMwMTI0NTExMQ=="},"nonce":"dxagr1rx/pYqFiH0c+2Yf14rduQ=","target":"2d2f7897e6d4c05d1b159cf1befe8f1eaab111a4077516ab695d0e978161409c","message":"This is lightly modified version, actually - attempt to add some parallel CPU instruction processing. Not sure about key distribution and final code performance but in any way...\n\n`\nuint32_t Hash_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint32_t hash32 = 2166136261;\n    unsigned long long hash64 = 14695981039346656037;//2166136261;\n    unsigned long long hash64_1 = 14695981039346656037;//2166136261;\n    size_t Cycles, NDhead;\n\n    if (wrdlen \u003e8) {\n        Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        NDhead = wrdlen - (Cycles\u003c\u003c3);\n\n        for(; Cycles--; str += 8) {\n            hash64 = ( hash64 ^ (*(long long *)(str)) ) * PRIME;\n            hash64_1 = ( hash64_1 ^ (*(long long *)(str+NDhead)) ) * PRIME;\n        }\n        hash64 = (hash64 ^ hash64_1) * PRIME;\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(long long *)str, (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n\n    hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n`\n`\nHash_Pippip(char const*, unsigned long):\n        mov     rax, QWORD PTR [rdi]\n        cmp     rsi, 8\n        jbe     .L2\n        movabs  rdx, -3750763034362895579\n        lea     rax, [rsi-1]\n        shr     rax, 4\n        lea     rcx, [8+rax*8]\n        mov     rax, rdx\n        sub     rsi, rcx\n        add     rcx, rdi\n.L3:\n        xor     rax, QWORD PTR [rdi]\n        xor     rdx, QWORD PTR [rdi+rsi]\n        add     rdi, 8\n        imul    rax, rax, 591798841\n        imul    rdx, rdx, 591798841\n        cmp     rdi, rcx\n        jne     .L3\n.L6:\n        xor     rax, rdx\n        imul    rax, rax, 591798841\n        mov     rdx, rax\n        shr     rdx, 32\n        xor     eax, edx\n        mov     edx, eax\n        shr     edx, 16\n        xor     eax, edx\n        ret\n.L2:\n        movabs  rdx, -3750763034362895579\n        mov     ecx, 8\n        sub     ecx, esi\n        sal     ecx, 3\n        sal     rax, cl\n        sar     rax, cl\n        jmp     .L6`","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572453052,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMwMTI0NTU0MQ=="},"nonce":"JMBJ3sVLi2JpBy1AbnAjtIrwlXU=","target":"2d2f7897e6d4c05d1b159cf1befe8f1eaab111a4077516ab695d0e978161409c","message":"@Sanmayce \nThis is lightly modified version, actually - attempt to add some parallel CPU instruction processing. Not sure about key distribution and final code performance but in any way...\n\n`\nuint32_t Hash_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint32_t hash32 = 2166136261;\n    unsigned long long hash64 = 14695981039346656037;//2166136261;\n    unsigned long long hash64_1 = 14695981039346656037;//2166136261;\n    size_t Cycles, NDhead;\n\n    if (wrdlen \u003e8) {\n        Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        NDhead = wrdlen - (Cycles\u003c\u003c3);\n\n        for(; Cycles--; str += 8) {\n            hash64 = ( hash64 ^ (*(long long *)(str)) ) * PRIME;\n            hash64_1 = ( hash64_1 ^ (*(long long *)(str+NDhead)) ) * PRIME;\n        }\n        hash64 = (hash64 ^ hash64_1) * PRIME;\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(long long *)str, (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n\n    hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n`\n`\nHash_Pippip(char const*, unsigned long):\n        mov     rax, QWORD PTR [rdi]\n        cmp     rsi, 8\n        jbe     .L2\n        movabs  rdx, -3750763034362895579\n        lea     rax, [rsi-1]\n        shr     rax, 4\n        lea     rcx, [8+rax*8]\n        mov     rax, rdx\n        sub     rsi, rcx\n        add     rcx, rdi\n.L3:\n        xor     rax, QWORD PTR [rdi]\n        xor     rdx, QWORD PTR [rdi+rsi]\n        add     rdi, 8\n        imul    rax, rax, 591798841\n        imul    rdx, rdx, 591798841\n        cmp     rdi, rcx\n        jne     .L3\n.L6:\n        xor     rax, rdx\n        imul    rax, rax, 591798841\n        mov     rdx, rax\n        shr     rdx, 32\n        xor     eax, edx\n        mov     edx, eax\n        shr     edx, 16\n        xor     eax, edx\n        ret\n.L2:\n        movabs  rdx, -3750763034362895579\n        mov     ecx, 8\n        sub     ecx, esi\n        sal     ecx, 3\n        sal     rax, cl\n        sar     rax, cl\n        jmp     .L6`","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572453073,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMwMTI0NTgxMg=="},"nonce":"pA+Wol/ePLh5fGl3RGh3pToWmLk=","target":"2d2f7897e6d4c05d1b159cf1befe8f1eaab111a4077516ab695d0e978161409c","message":"@Sanmayce \nThis is lightly modified version, actually - attempt to add some parallel CPU instruction processing. Not sure about keys distribution and final code performance but in any way...\n\n`\nuint32_t Hash_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint32_t hash32 = 2166136261;\n    unsigned long long hash64 = 14695981039346656037;//2166136261;\n    unsigned long long hash64_1 = 14695981039346656037;//2166136261;\n    size_t Cycles, NDhead;\n\n    if (wrdlen \u003e8) {\n        Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        NDhead = wrdlen - (Cycles\u003c\u003c3);\n\n        for(; Cycles--; str += 8) {\n            hash64 = ( hash64 ^ (*(long long *)(str)) ) * PRIME;\n            hash64_1 = ( hash64_1 ^ (*(long long *)(str+NDhead)) ) * PRIME;\n        }\n        hash64 = (hash64 ^ hash64_1) * PRIME;\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(long long *)str, (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n\n    hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n`\n`\nHash_Pippip(char const*, unsigned long):\n        mov     rax, QWORD PTR [rdi]\n        cmp     rsi, 8\n        jbe     .L2\n        movabs  rdx, -3750763034362895579\n        lea     rax, [rsi-1]\n        shr     rax, 4\n        lea     rcx, [8+rax*8]\n        mov     rax, rdx\n        sub     rsi, rcx\n        add     rcx, rdi\n.L3:\n        xor     rax, QWORD PTR [rdi]\n        xor     rdx, QWORD PTR [rdi+rsi]\n        add     rdi, 8\n        imul    rax, rax, 591798841\n        imul    rdx, rdx, 591798841\n        cmp     rdi, rcx\n        jne     .L3\n.L6:\n        xor     rax, rdx\n        imul    rax, rax, 591798841\n        mov     rdx, rax\n        shr     rdx, 32\n        xor     eax, edx\n        mov     edx, eax\n        shr     edx, 16\n        xor     eax, edx\n        ret\n.L2:\n        movabs  rdx, -3750763034362895579\n        mov     ecx, 8\n        sub     ecx, esi\n        sal     ecx, 3\n        sal     rax, cl\n        sar     rax, cl\n        jmp     .L6`","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572453252,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMwMTI0NzkyMg=="},"nonce":"YR4FM/Aloyt/CxJNkBLcozIe4d4=","target":"2d2f7897e6d4c05d1b159cf1befe8f1eaab111a4077516ab695d0e978161409c","message":"@Sanmayce \nThis is lightly modified version, actually - attempt to add some parallel CPU instruction processing. Not sure about keys distribution and final code performance but in any way...\n\n`\nuint32_t Hash_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint32_t hash32;// = 2166136261;\n    unsigned long long hash64 = 14695981039346656037;//2166136261;\n    unsigned long long hash64_1 = 14695981039346656037;//2166136261;\n    size_t Cycles, NDhead;\n\n    if (wrdlen \u003e8) {\n        Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        NDhead = wrdlen - (Cycles\u003c\u003c3);\n\n        for(; Cycles--; str += 8) {\n            hash64 = ( hash64 ^ (*(long long *)(str)) ) * PRIME;\n            hash64_1 = ( hash64_1 ^ (*(long long *)(str+NDhead)) ) * PRIME;\n        }\n        hash64 = (hash64 ^ hash64_1) * PRIME;\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(long long *)str, (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n\n    hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n`\n`\nHash_Pippip(char const*, unsigned long):\n        mov     rax, QWORD PTR [rdi]\n        cmp     rsi, 8\n        jbe     .L2\n        movabs  rdx, -3750763034362895579\n        lea     rax, [rsi-1]\n        shr     rax, 4\n        lea     rcx, [8+rax*8]\n        mov     rax, rdx\n        sub     rsi, rcx\n        add     rcx, rdi\n.L3:\n        xor     rax, QWORD PTR [rdi]\n        xor     rdx, QWORD PTR [rdi+rsi]\n        add     rdi, 8\n        imul    rax, rax, 591798841\n        imul    rdx, rdx, 591798841\n        cmp     rdi, rcx\n        jne     .L3\n.L6:\n        xor     rax, rdx\n        imul    rax, rax, 591798841\n        mov     rdx, rax\n        shr     rdx, 32\n        xor     eax, edx\n        mov     edx, eax\n        shr     edx, 16\n        xor     eax, edx\n        ret\n.L2:\n        movabs  rdx, -3750763034362895579\n        mov     ecx, 8\n        sub     ecx, esi\n        sal     ecx, 3\n        sal     rax, cl\n        sar     rax, cl\n        jmp     .L6`","files":null}]}