{"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"ops":[{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1609619911,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlRWRpdDo0NzQxNzc4MzI="},"nonce":"MgWeLGbtj0d2aIPJQm0lc5YnZUw=","target":"feadc840be123e810db7ed3a5d58cbb9a658d92c863ce8cef472e06285f8e0ee","message":"OK, finally I was able to create a \"competitive speed\" hash function. It gives me 13.2GB/s hashing speed, that should translate to about 14.5GB/s on your bench I think. This hash function `prvhash42f` works similarly to other PRVHASH variants, but is structurally very different - I've not studied it well yet, so I cannot tell much about it yet, except that it works for hashing. `prvhash42` and `prvhash42s` are based on `core` functions that I've studied and described very well, they are far safer bet, even if they are slower.\n\n`prvhash42f` is probably not the best function for table hash use - it's large. But it can stand scrutiny against wyhash-like structures as it does not exploit \"message by message\" multiplications.\n\nLike with other PRVHASH variants, you may benchmark 32, 64 and 128-bit variants.\n\nhttps://github.com/avaneev/prvhash","files":null},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1609623879,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDc1MzUzMzU2NA==","github-url":"https://github.com/rurban/smhasher/issues/178#issuecomment-753533564"},"nonce":"/v77W/Ipc4zl5VeUnAwpTIBBU04=","message":"You may also update speed benchmarks of `prvhash42s` - I've only optimized the code, on LLVM it's 12-14% faster now, on Ryzen 3700X.","files":null}]}