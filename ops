{"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"ops":[{"type":3,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572285202,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU0NzA2OTU1MQ==","github-url":"https://github.com/rurban/smhasher/issues/75#issuecomment-547069551"},"nonce":"6/zc5zAdmOrEKlrWChfABL59iu4=","message":"\u003e Thanks, probably you mean the \"above the law\" fetching of QWORD without checking the end of the key, right?\n\nCorrect. Yes, if we add 8 bytes in some manner it'll help, but if we'are talking about generic algorithm (function) we can't have this limitation. In any way...","files":null},{"type":3,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572286530,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU0NzA3ODk1NQ==","github-url":"https://github.com/rurban/smhasher/issues/75#issuecomment-547078955"},"nonce":"D57Nt8B/P0BBrsywKdpQPUuP0j8=","message":"This small change generates better code (I mean) for gcc and VS compiler. Even if we want to use input wrdlen-type as uint32_t we need to change \"int\"-types to uint32_t to produce some better code.\n\nuint32_t FNV1A_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint64_t hash64 = 14695981039346656037;\n    if (wrdlen \u003e 8) {\n        size_t Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        size_t NDhead = wrdlen - (Cycles\u003c\u003c3);\n        for(; Cycles--; str += 8)\n        {\n            hash64 = ( hash64 ^ (*(uint64_t *)(str)) ) * PRIME;        \n            hash64 = ( hash64 ^ (*(uint64_t *)(str+NDhead)) ) * PRIME;        \n        }\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(uint64_t *)(str+0), (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n    \n    uint32_t hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572286606,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDI5OTg5NjY5Mg=="},"nonce":"6Bb/6O/Y4Yu43ZEpnFHI7vQxwbQ=","target":"957c2f838a726633970f02824febc41f82bb8b90d9bfaa66c24c20129a23ac05","message":"This small change generates better code (I mean) for gcc and VS compiler. Even if we want to use input wrdlen-type as uint32_t we need to change \"int\"-types to uint32_t to produce some better code.\n\nuint32_t FNV1A_Pippip(const char *str, size_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint64_t hash64 = 14695981039346656037;\n    if (wrdlen \u003e 8) {\n        size_t Cycles = ((wrdlen - 1)\u003e\u003e4) + 1;\n        size_t NDhead = wrdlen - (Cycles\u003c\u003c3);\n        for(; Cycles--; str += 8)\n        {\n            hash64 = ( hash64 ^ (*(uint64_t *)(str)) ) * PRIME;        \n            hash64 = ( hash64 ^ (*(uint64_t *)(str+NDhead)) ) * PRIME;        \n        }\n    } else\n        hash64 = ( hash64 ^ _PADr_KAZE(*(uint64_t *)(str+0), (8-wrdlen)\u003c\u003c3) ) * PRIME;        \n    \n    uint32_t hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n\nFNV1A_Pippip(char const*, unsigned long):\n        mov     rax, QWORD PTR [rdi]\n        cmp     rsi, 8\n        jbe     .L2\n        lea     rax, [rsi-1]\n        shr     rax, 4\n        lea     rdx, [8+rax*8]\n        movabs  rax, -3750763034362895579\n        sub     rsi, rdx\n        add     rdx, rdi\n.L3:\n        xor     rax, QWORD PTR [rdi]\n        add     rdi, 8\n        imul    rax, rax, 591798841\n        xor     rax, QWORD PTR [rdi-8+rsi]\n        imul    rax, rax, 591798841\n        cmp     rdi, rdx\n        jne     .L3\n.L4:\n        mov     rdx, rax\n        shr     rdx, 32\n        xor     eax, edx\n        mov     edx, eax\n        shr     edx, 16\n        xor     eax, edx\n        ret\n.L2:\n        movabs  rdx, -3750763034362895579\n        mov     ecx, 8\n        sub     ecx, esi\n        sal     ecx, 3\n        sal     rax, cl\n        shr     rax, cl\n        xor     rax, rdx\n        imul    rax, rax, 591798841\n        jmp     .L4\n_GLOBAL__sub_I_FNV1A_Pippip(char const*, unsigned long):\n        sub     rsp, 8\n        mov     edi, OFFSET FLAT:_ZStL8__ioinit\n        call    std::ios_base::Init::Init() [complete object constructor]\n        mov     edx, OFFSET FLAT:__dso_handle\n        mov     esi, OFFSET FLAT:_ZStL8__ioinit\n        mov     edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev\n        add     rsp, 8\n        jmp     __cxa_atexit","files":null}]}