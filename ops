{"author":{"id":"6eee5efae6ac4c22551887b8f66b9bbb345d45511a0675f837fab3c1b02acdca"},"ops":[{"type":3,"author":{"id":"6eee5efae6ac4c22551887b8f66b9bbb345d45511a0675f837fab3c1b02acdca"},"timestamp":1561886974,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDUwNzAyMTc2NA==","github-url":"https://github.com/rurban/smhasher/issues/31#issuecomment-507021764"},"nonce":"vgeDHMf+HsQwCTpoqXa1/pp5v80=","message":"The really valuable things in Yves' fork are:\n 1. Configurable seed, state and hash sizes up to 128 bits\n 2. (Optional) state-generation stage for hash funcs with expensive seed-\u003estate\n 3. Improved tests with g-test\n\nI can't emphasize 3 enough. There are tons of hash functions which pass your fork and which you recommend, but which fail spectacularly with the stricter tests in Yves'. The avalanche test in particular is a massive improvement. This is not magic or the test being overzealous - I can usually find and fix the problem in a very predictable way (most commonly a weak final mixing stage). Going the other direction, I can easily take a hash function which just passes Yves', remove a bunch of things (again, usually in the final mixing stage where operations are by necessity linearized) and have it pass on yours for a significant speed increase.\n\nI don't recall every single failure, but I recently added xxh3 to my private fork of Yves' and it fails avalanche on 0-3 byte keys. Other failures have been even more spectacular.\n\nYves hasn't been actively working on his fork in some time. You're actively maintaining yours. It would be ideal if we could have the improvements from Yves' fork in an actively maintained fork. It would also be hugely beneficial if your fork, which is viewed as the canonical one right now, applied the most rigourous standards possible to ensure people used quality hash functions, which is not currently the case.","files":null},{"type":6,"author":{"id":"6eee5efae6ac4c22551887b8f66b9bbb345d45511a0675f837fab3c1b02acdca"},"timestamp":1561886997,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDI0MzAwMDQxNw=="},"nonce":"Y4nmghgXKWNNNl3eqDZu4/mJ78c=","target":"edb0bdd485c84c5a3ab4eba0b5135e43acf0b9ad1c8e37ea5960e8a5af92758c","message":"The really valuable things in Yves' fork are:\n 1. Configurable seed, state and hash sizes up to 128 bits (and beyond, presumably)\n 2. (Optional) state-generation stage for hash funcs with expensive seed-\u003estate\n 3. Improved tests with g-test\n\nI can't emphasize 3 enough. There are tons of hash functions which pass your fork and which you recommend, but which fail spectacularly with the stricter tests in Yves'. The avalanche test in particular is a massive improvement. This is not magic or the test being overzealous - I can usually find and fix the problem in a very predictable way (most commonly a weak final mixing stage). Going the other direction, I can easily take a hash function which just passes Yves', remove a bunch of things (again, usually in the final mixing stage where operations are by necessity linearized) and have it pass on yours for a significant speed increase.\n\nI don't recall every single failure, but I recently added xxh3 to my private fork of Yves' and it fails avalanche on 0-3 byte keys. Other failures have been even more spectacular.\n\nYves hasn't been actively working on his fork in some time. You're actively maintaining yours. It would be ideal if we could have the improvements from Yves' fork in an actively maintained fork. It would also be hugely beneficial if your fork, which is viewed as the canonical one right now, applied the most rigourous standards possible to ensure people used quality hash functions, which is not currently the case.","files":null}]}