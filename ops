{"author":{"id":"9556b3528bb71e828da55722f4a91f25e84fafcbbdb4e86feb42a2d9eac4693e"},"ops":[{"type":3,"author":{"id":"9556b3528bb71e828da55722f4a91f25e84fafcbbdb4e86feb42a2d9eac4693e"},"timestamp":1571414818,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU0MzgxMjk1MA==","github-url":"https://github.com/rurban/smhasher/issues/73#issuecomment-543812950"},"nonce":"tx3uBq1iue+tAMHYvP6FU2RqlDA=","message":"@Sanmayce, for SHA you can get ANY 32-bit from it's result. For Pelle Evensen's mixer it is easy to construct the simple hash function:\n\n```\n#include \u003cstdint.h\u003e\n#include \u003cstring.h\u003e\n\nstatic uint64_t rrxmrrxmsx_0(uint64_t v) {\n  /* Pelle Evensen's mixer, https://bit.ly/2HOfynt */\n  v ^= (v \u003c\u003c 39 | v \u003e\u003e 25) ^ (v \u003c\u003c 14 | v \u003e\u003e 50);\n  v *= UINT64_C(0xA24BAED4963EE407);\n  v ^= (v \u003c\u003c 40 | v \u003e\u003e 24) ^ (v \u003c\u003c 15 | v \u003e\u003e 49);\n  v *= UINT64_C(0x9FB21C651E98DF25);\n  return v ^ v \u003e\u003e 28;\n}\n\nuint64_t hash_based_on_Pelle_Evensen_mixer(const void *data, size_t bytes, uint64_t seed) {\n    uint64_t tmp, hash = rrxmrrxmsx_0(rrxmrrxmsx_0(seed) + bytes);\n    while(bytes \u003e= sizeof(tmp)) {\n        memcpy(\u0026tmp, data, sizeof(tmp));\n        data = (char*)data + sizeof(tmp);\n        hash = rrxmrrxmsx_0(hash + tmp);\n        bytes -= sizeof(tmp);\n    }\n    if (bytes) {\n        tmp = 0;\n        memcpy(\u0026tmp, data, bytes);\n        hash = rrxmrrxmsx_0(hash + tmp);\n    }\n    return hash;\n}\n```","files":null}]}