{"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"ops":[{"type":3,"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"timestamp":1597278637,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY3MzE3ODMzMQ==","github-url":"https://github.com/rurban/smhasher/issues/121#issuecomment-673178331"},"nonce":"0XN2kRdvIJVO/vrzNOoHye9eRRU=","message":"\u003e to compare with pippip which does not pass smhasher and does not comsume every bytes, one should set WYHASH_CONDOM 0 it will be faster.\n\nOkay, it remains to be seen.\nAs for \"pippip which does not pass smhasher and does not comsume every bytes\", please show one e.g. English text/wordlist corpus where the combined performance of speed\u0026dispersion is better for WYhash. For instance, you use some spellcheck wordlist, good, how about adding also one truly heavy-duty wordlist as the 42 million unique words in English Wikipedia using 1\u003c\u003c26 bit hashtable.\nHow come \"does not consume every byte\", it covers the whole key!\nAfter all, the smhasher testsuite is overkill for general lookups, that is why I get a bit irritated when much stronger hashers are put in another league, there is record on 100m sprint - no one cares the athlete is black, red, pink, brown or ... mutant.\nHaving excellent dispersion is awesome, yet, I challenge everyone to show me a hashtable case/benchmark where FNV1A-Pippip is not fastest (for small keys \u003c=128) - of course using inserting/searching for keys as well, not only raw hashing.\n\nTried to compile with the 'wyhash.h' and WYHASH_CONDOM 0, however ICL v15.0 complained:\n\n\n```\nE:\\Lookuperorama.c_r8++\u003eicl /TP /O3 /arch:SSE4.1 Lookuperorama.c -D_N_XMM -D_N_prefetch_4096 -D_N_alone -D_N_HIGH_PRIORITY -D_icl_mumbo_jumbo_ /FAcs -DHashInBITS=24 -DHashChunkSizeInBITS=24 -DRAMpoolI\nnKB=5120 -DBtreeHEURISTIC -D_WIN32_ENVIRONMENT_ -DLongestLineInclusive=64 -D_N_WY\nIntel(R) C++ Compiler XE for applications running on Intel(R) 64, Version 15.0.0.108 Build 20140726\nCopyright (C) 1985-2014 Intel Corporation.  All rights reserved.\n\nLookuperorama.c\nE:\\Lookuperorama.c_r8++\\wyhash.h(131): error: identifier \"__builtin_popcountll\" is undefined\n          if(__builtin_popcountll(secret[j]^secret[i])!=32){ ok=0; break; }\n             ^\n\nLookuperorama.c(7279): warning #592: variable \"TargetSize2\" is used before its value is set\n        fprintf( fp_outLOG, \"| %s / %sMB/s        \",  _ui64toaKAZEzerocomma(TargetSize2, llTOaDigits2, 10)+(26-13), _ui64toaKAZEzerocomma(k2, llTOaDigits3, 10)+(26-7) );\n                                                                            ^\n\ncompilation aborted for Lookuperorama.c (code 2)\n```\n\nMaybe, the counterpart __popcnt64() to __builtin_popcountll() should be added if not GCC?","files":null}]}