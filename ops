{"author":{"id":"c40aa850a65565eefc736368669dae3dde2b36a9f072b6a3ebcdadb10a1406cc"},"ops":[{"type":3,"timestamp":1654681292,"metadata":{"github-id":"IC_kwDOARWYbc5EhvZc","github-url":"https://github.com/rurban/smhasher/issues/69#issuecomment-1149695580"},"nonce":"f2U8nOrpwPaDlRw84+nQmFfcUvM=","message":"Is it acceptable to use a C++ port of the Rust implementation? This hash is quite small and I recently implemented a similar hash in Zig that differs only in that it does fewer rounds for non-multiple-of-8 and assumes it can read up to 7 bytes past the end.\n\n```zig\nconst Hasher = struct {\n    const K: u64 = 0x517cc1b727220a95;\n    hash: u64 = 0,\n    pub inline fn add(self: *Hasher, i: u64) void {\n        self.hash = (((self.hash \u003c\u003c 5) | (self.hash \u003e\u003e 59)) ^ i) *% K;\n    }\n\n    pub inline fn write(self: *Hasher, start: [*]u8, len: u64) void {\n        const end = start + len;\n        var p = start;\n        while (@ptrToInt(p + 8) \u003c= @ptrToInt(end)) {\n            self.add(std.mem.readIntLittle(u64, p[0..8]));\n            p += 8;\n        }\n        if (@ptrToInt(p) \u003c @ptrToInt(end)) {\n            // for this last read,\n            // the low bytes are our string and the high bytes are garbage\n            const garbage_bytes = @intCast(u6, 8 - (@ptrToInt(end) - @ptrToInt(p)));\n            self.add(std.mem.readIntLittle(u64, p[0..8]) \u003c\u003c garbage_bytes * 8);\n        }\n    }\n};\n```\n\nThis obviously isn't useful, but I can make a more faithful C++ port if that would help.","files":null},{"type":6,"timestamp":1654681310,"metadata":{"github-id":"UCE_lALOARWYbc5EhvZcziP6Qbc"},"nonce":"fmDsSfVqK8QqzBGD5BbyrlpMZZg=","target":"65591964c3d5c7d7dc756692c9a20e1a5fbc1ce9f589730fd36ba5569e71d426","message":"Is it acceptable to use a C++ port of the Rust implementation? This hash is quite small and I recently implemented a similar hash in Zig that differs only in that it does fewer rounds for non-multiple-of-8 input sizes and assumes it can read up to 7 bytes past the end.\n\n```zig\nconst Hasher = struct {\n    const K: u64 = 0x517cc1b727220a95;\n    hash: u64 = 0,\n    pub inline fn add(self: *Hasher, i: u64) void {\n        self.hash = (((self.hash \u003c\u003c 5) | (self.hash \u003e\u003e 59)) ^ i) *% K;\n    }\n\n    pub inline fn write(self: *Hasher, start: [*]u8, len: u64) void {\n        const end = start + len;\n        var p = start;\n        while (@ptrToInt(p + 8) \u003c= @ptrToInt(end)) {\n            self.add(std.mem.readIntLittle(u64, p[0..8]));\n            p += 8;\n        }\n        if (@ptrToInt(p) \u003c @ptrToInt(end)) {\n            // for this last read,\n            // the low bytes are our string and the high bytes are garbage\n            const garbage_bytes = @intCast(u6, 8 - (@ptrToInt(end) - @ptrToInt(p)));\n            self.add(std.mem.readIntLittle(u64, p[0..8]) \u003c\u003c garbage_bytes * 8);\n        }\n    }\n};\n```\n\nThis obviously isn't useful, but I can make a more faithful C++ port if that would help.","files":null},{"type":6,"timestamp":1654681365,"metadata":{"github-id":"UCE_lALOARWYbc5EhvZcziP6Q5U"},"nonce":"7B+uf7jPD4o1D51ZQXitn2zXZXQ=","target":"65591964c3d5c7d7dc756692c9a20e1a5fbc1ce9f589730fd36ba5569e71d426","message":"Is it acceptable to use a C++ port of the Rust implementation? This hash is quite small and I recently implemented a similar hash in Zig that differs only in that it does fewer rounds for non-multiple-of-8 input sizes, assumes little endian, and assumes it can read up to 7 bytes past the end.\n\n```zig\nconst Hasher = struct {\n    const K: u64 = 0x517cc1b727220a95;\n    hash: u64 = 0,\n    pub inline fn add(self: *Hasher, i: u64) void {\n        self.hash = (((self.hash \u003c\u003c 5) | (self.hash \u003e\u003e 59)) ^ i) *% K;\n    }\n\n    pub inline fn write(self: *Hasher, start: [*]u8, len: u64) void {\n        const end = start + len;\n        var p = start;\n        while (@ptrToInt(p + 8) \u003c= @ptrToInt(end)) {\n            self.add(std.mem.readIntLittle(u64, p[0..8]));\n            p += 8;\n        }\n        if (@ptrToInt(p) \u003c @ptrToInt(end)) {\n            // for this last read,\n            // the low bytes are our string and the high bytes are garbage\n            const garbage_bytes = @intCast(u6, 8 - (@ptrToInt(end) - @ptrToInt(p)));\n            self.add(std.mem.readIntLittle(u64, p[0..8]) \u003c\u003c garbage_bytes * 8);\n        }\n    }\n};\n```\n\nThis obviously isn't useful, but I can make a more faithful C++ port if that would help.","files":null},{"type":6,"timestamp":1654681379,"metadata":{"github-id":"UCE_lALOARWYbc5EhvZcziP6RAU"},"nonce":"qAJDg/dxSL3ZJ3j6+wCqvWLhvg0=","target":"65591964c3d5c7d7dc756692c9a20e1a5fbc1ce9f589730fd36ba5569e71d426","message":"Is it acceptable to use a C++ port of the Rust implementation? This hash is quite small and I recently implemented a similar hash in Zig that differs only in that it does fewer rounds for non-multiple-of-8 input sizes and assumes it can read up to 7 bytes past the end.\n\n```zig\nconst Hasher = struct {\n    const K: u64 = 0x517cc1b727220a95;\n    hash: u64 = 0,\n    pub inline fn add(self: *Hasher, i: u64) void {\n        self.hash = (((self.hash \u003c\u003c 5) | (self.hash \u003e\u003e 59)) ^ i) *% K;\n    }\n\n    pub inline fn write(self: *Hasher, start: [*]u8, len: u64) void {\n        const end = start + len;\n        var p = start;\n        while (@ptrToInt(p + 8) \u003c= @ptrToInt(end)) {\n            self.add(std.mem.readIntLittle(u64, p[0..8]));\n            p += 8;\n        }\n        if (@ptrToInt(p) \u003c @ptrToInt(end)) {\n            // for this last read,\n            // the low bytes are our string and the high bytes are garbage\n            const garbage_bytes = @intCast(u6, 8 - (@ptrToInt(end) - @ptrToInt(p)));\n            self.add(std.mem.readIntLittle(u64, p[0..8]) \u003c\u003c garbage_bytes * 8);\n        }\n    }\n};\n```\n\nThis obviously isn't useful, but I can make a more faithful C++ port if that would help.","files":null}]}