{"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"ops":[{"type":3,"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"timestamp":1573213368,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU1MTY0NDI0Mw==","github-url":"https://github.com/rurban/smhasher/issues/76#issuecomment-551644243"},"nonce":"Q9ViwLF8hoxojNMT59F74A7JrxA=","message":"\u003eBut I also want to add tests for the i-cache effects on real hash tables...\n\nThat's talking.\nTo me, most of the confusion, regarding \"HASHING\", comes from the mismixage of hashers for table lookuping and hashers for checksumming.\nIt would be wonderful to have both usecases handled by a single hasher, but only WYHASH and XXH3 are trying to bridge the gap.\nThink for a moment, what is the benefit of having the strongest DISPERSER SHA3-224 as a hash for table lookups!\n\nIt turns out, wordlists are excellent keyset corpora - they torture the hasher by forcing it to go different codepaths, usually 1..31 chars - this range is not arbitrary - this is one of the TOP REAL-WORLD niches, plus, the longest word in HERITAGE dictionary happened to be 31 in length, a quick run (on i5-7200U) for wordlists:\n\n```\nKAZE_enwiki-20190920-pages-articles.xml.SORTED.wrd: \n42206534 lines read\n134217728 elements in the table (27 bits)\n        Pippip_Yurii:    8272603 [5996107]\n            LeoPelle:   22537488 [5996503]\n           wyhash_v3:   11693954 [5989881]\n              FNV-1a:   11988933 [5980248]\n              Larson:   10991426 [5937238]\n              CRC-32:   11564283 [5843653]\n             Murmur3:   11365844 [5992379]\n         XXHstrong32:   12409653 [6007552]\n           iSCSI CRC:    8468083 [5803092]\n \nKAZE_(_usr_share_dict)_american-english: \n123115 lines read\n262144 elements in the table (18 bits)\n        Pippip_Yurii:      10426 [24838]\n            LeoPelle:      27370 [24781]\n           wyhash_v3:      16827 [24678]\n              FNV-1a:      16542 [24792]\n              Larson:      16567 [24973]\n              CRC-32:      16380 [24824]\n             Murmur3:      16243 [24702]\n         XXHstrong32:      17834 [24849]\n           iSCSI CRC:      12450 [24709]\n \nKAZE_(_usr_share_dict)_french: \n221377 lines read\n524288 elements in the table (19 bits)\n        Pippip_Yurii:      23659 [40764]\n            LeoPelle:      69040 [40723]\n           wyhash_v3:      37250 [40727]\n              FNV-1a:      39814 [40857]\n              Larson:      38862 [40595]\n              CRC-32:      36671 [40720]\n             Murmur3:      35129 [40715]\n         XXHstrong32:      40155 [40862]\n           iSCSI CRC:      25129 [40740]\n \nKAZE_(_usr_share_dict)_ngerman: \n304736 lines read\n1048576 elements in the table (20 bits)\n        Pippip_Yurii:      33887 [40330]\n            LeoPelle:    1104690 [40057]\n           wyhash_v3:      52027 [40036]\n              FNV-1a:      60010 [40197]\n              Larson:      55601 [40217]\n              CRC-32:      54157 [40027]\n             Murmur3:      51374 [40316]\n         XXHstrong32:      58387 [40399]\n           iSCSI CRC:      36136 [40059]\n``` \nLooking forward to seeing 'FNV1A-Pippip_Yurii' choked, distributionwise, in some scenario.\n\nReini, along with speed testing, collisions of all UNI/BI/TRI/TETRA bytes is a must-see, I reckon:\n```\n// BENCHMARKING UNIbytes/BIbytes/TRIbytes/TETRAbytes [\n\nfor (dumbino=1; dumbino\u003c=4; dumbino++) { // The buffer for the KT should be 4GB in total i.e. 30bit x 4bytes-per-slot\n\nmemset(pointerflush, 0, (1LL\u003c\u003cHashSizeInBits)*sizeof(uint32_t));\nif (dumbino==1) printf( \"FNV1A_Pippip           : Hashing all UNIbytes,   i.e. all  8bit variants into  8bit hashtable ... \");\nif (dumbino==2) printf( \"FNV1A_Pippip           : Hashing all BIbytes,    i.e. all 16bit variants into 16bit hashtable ... \");\nif (dumbino==3) printf( \"FNV1A_Pippip           : Hashing all TRIbytes,   i.e. all 24bit variants into 24bit hashtable ... \");\nif (dumbino==4) printf( \"FNV1A_Pippip           : Hashing all TETRAbytes, i.e. all 32bit variants into 32bit hashtable ... \");\nfor (BenchSmallKeys=0; BenchSmallKeys \u003c (1LL\u003c\u003c(dumbino\u003c\u003c3)); BenchSmallKeys++) {\n\tSlot = ( FNV1A_Pippip_Yurii((char *)\u0026BenchSmallKeys, dumbino) \u0026 ((1LL\u003c\u003c(dumbino\u003c\u003c3))-1) )\u003c\u003c0;\n\t//memcpy( \u0026PseudoLinkedPointer, pointerflush+Slot, 4 );\n\t//PseudoLinkedPointer++; //if (PseudoLinkedPointer==255) printf( \"\\nGrmbl, a slot with 255 collisions exist!\\n\" );\n\t//memcpy( pointerflush+Slot, \u0026PseudoLinkedPointer, 4 );\n\tPseudoLinkedPointer = 1;\n\tmemcpy( pointerflush+Slot, \u0026PseudoLinkedPointer, 4-3 );\n}\nUsedSlots=0;\nfor (BenchSmallKeys=0; BenchSmallKeys \u003c (1LL\u003c\u003c(dumbino\u003c\u003c3)); BenchSmallKeys++) {\n\n\tif (*(char*)(pointerflush+BenchSmallKeys)) UsedSlots++;\n}\nprintf( \"Used Slots = %llu; \", UsedSlots);\nprintf( \"Utilization = (UsedSlots/AllSlots)*100%% = %5.2f%% (the-bigger-the-better)\\n\", (float)(UsedSlots*100)/(float)(1LL\u003c\u003c(dumbino\u003c\u003c3)));\n} // dumbino\n\n// BENCHMARKING UNIbytes/BIbytes/TRIbytes/TETRAbytes ]\n```\nSurprisingly, 'Pippip' outdisperses XXH3 in WORDS and DWORDS!\n\n```\nFNV1A_Pippip: Hashing all BIbytes,    i.e. all 16bit variants into 16bit hashtable ... Used Slots = 41520; Utilization = (UsedSlots/AllSlots)*100% = 63.35% (the-bigger-the-better)\nXXH3_64bits : Hashing all BIbytes,    i.e. all 16bit variants into 16bit hashtable ... Used Slots = 41483; Utilization = (UsedSlots/AllSlots)*100% = 63.30% (the-bigger-the-better)\n\nFNV1A_Pippip: Hashing all TETRAbytes, i.e. all 32bit variants into 32bit hashtable ... Used Slots = 2716930650; Utilization = (UsedSlots/AllSlots)*100% = 63.26% (the-bigger-the-better)\nXXH3_64bits : Hashing all TETRAbytes, i.e. all 32bit variants into 32bit hashtable ... Used Slots = 2714932144; Utilization = (UsedSlots/AllSlots)*100% = 63.21% (the-bigger-the-better)\n```","files":null}]}