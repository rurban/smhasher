{"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"ops":[{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572274388,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDI5OTc1NzAxMQ=="},"nonce":"7jXRK49pOXDhcuhrKyyDfHhZGoM=","target":"d0dcb39569fc86db02dd3944ea0eff23bdabe574ca08eb8d4036423b49239702","message":"Your algorithm (Hash_Pippip), can cross a MMU page boundary and can produce general protection fault.\n\nAs option I propose this (a bit modified FNV1a):\n\nuint32_t fnv_1a(const char* key, size_t len)\n{\n    uint32_t hash32 = 2166136261;\n    const uint32_t PRIME = 1607;\n\n    for (size_t cnt = len / sizeof(uint32_t); cnt--; key += sizeof(uint32_t))\n        hash32 = (hash32 ^ (*(uint32_t*)key)) * PRIME;\n\n    if (len \u0026 sizeof(uint16_t)) {\n        hash32 = (hash32 ^ (*(uint16_t*)key)) * PRIME;\n        key += sizeof(uint16_t);\n    }\n    if (len \u0026 1)\n        hash32 = (hash32 ^ (*key)) * PRIME;\n\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572275071,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDI5OTc2NTUyNA=="},"nonce":"5rT96z0oCGEZinzoY24nua6wEh4=","target":"d0dcb39569fc86db02dd3944ea0eff23bdabe574ca08eb8d4036423b49239702","message":"Your algorithm (Hash_Pippip), can cross a MMU page boundary and can produce general protection fault.\n\nAs option I propose this (a bit modified FNV1a):\n\nuint32_t fnv_1a(const char* key, size_t len)\n{\n    uint32_t hash32 = 2166136261;\n    const uint32_t PRIME = 1607;\n\n    for (const char* end = key + len; key \u003c end; key += sizeof(uint32_t))\n        hash32 = (hash32 ^ (*(uint32_t*)key)) * PRIME;\n\n    if (len \u0026 sizeof(uint16_t)) {\n        hash32 = (hash32 ^ (*(uint16_t*)key)) * PRIME;\n        key += sizeof(uint16_t);\n    }\n    if (len \u0026 1)\n        hash32 = (hash32 ^ (*key)) * PRIME;\n\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572275103,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDI5OTc2NTk4NQ=="},"nonce":"MZ78lsElHxklFJ9E4FfPTsjHlUQ=","target":"d0dcb39569fc86db02dd3944ea0eff23bdabe574ca08eb8d4036423b49239702","message":"Your algorithm (Hash_Pippip), can cross a MMU page boundary and can produce general protection fault.\n\nAs option I propose this (a bit modified FNV1a):\n\nuint32_t fnv_1a(const char* key, size_t len)\n{\n    uint32_t hash32 = 2166136261;\n    const uint32_t PRIME = 1607;\n\n    for (const char* end = key + len; key \u003c end; key += sizeof(uint32_t))\n        hash32 = (hash32 ^ (*(uint32_t*)key)) * PRIME;\n\n    if (len \u0026 sizeof(uint16_t)) {\n        hash32 = (hash32 ^ (*(uint16_t*)key)) * PRIME;\n        key += sizeof(uint16_t);\n    }\n    if (len \u0026 1)\n        hash32 = (hash32 ^ (*key)) * PRIME;\n\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}","files":null},{"type":6,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572275245,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDI5OTc2NzgwMw=="},"nonce":"686+Q9vYWzRjJu3qEHcw7vlGzjg=","target":"d0dcb39569fc86db02dd3944ea0eff23bdabe574ca08eb8d4036423b49239702","message":"Your algorithm (Hash_Pippip), can cross a MMU page boundary and can produce general protection fault.\n\nAs option I propose this (a bit modified FNV1a):\n\nuint32_t fnv_1a(const char* key, size_t len)\n{\n    uint32_t hash32 = 2166136261;\n    const uint32_t PRIME = 1607;\n\n    for (size_t cnt = len / sizeof(uint32_t); cnt--; key += sizeof(uint32_t))\n        hash32 = (hash32 ^ (*(uint32_t*)key)) * PRIME;\n\n    if (len \u0026 sizeof(uint16_t)) {\n        hash32 = (hash32 ^ (*(uint16_t*)key)) * PRIME;\n        key += sizeof(uint16_t);\n    }\n    if (len \u0026 1)\n        hash32 = (hash32 ^ (*key)) * PRIME;\n\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}","files":null}]}