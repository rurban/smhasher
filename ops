{"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"ops":[{"type":6,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1573834998,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDMwOTkwMjQ0MQ=="},"nonce":"DCtURW343r6hEzSQMjKqhZiaLqU=","target":"d0dcb39569fc86db02dd3944ea0eff23bdabe574ca08eb8d4036423b49239702","message":"Your algorithm (Hash_Pippip), can cross a MMU page boundary and can produce general protection fault.\n\nAs option I propose this (a bit modified FNV1a):\n```\nuint32_t fnv_1a(const char* key, size_t len)\n{\n    uint32_t hash32 = 2166136261;\n    const uint32_t PRIME = 1607;\n\n    for (size_t cnt = len / sizeof(uint32_t); cnt--; key += sizeof(uint32_t))\n        hash32 = (hash32 ^ (*(uint32_t*)key)) * PRIME;\n\n    if (len \u0026 sizeof(uint16_t)) {\n        hash32 = (hash32 ^ (*(uint16_t*)key)) * PRIME;\n        key += sizeof(uint16_t);\n    }\n    if (len \u0026 1)\n        hash32 = (hash32 ^ (*key)) * PRIME;\n\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n```","files":null}]}