{"author":{"id":"865bf723a9214027b17304fed4f98ae83e229e6421297d65bb8ed683dbeaeb5d"},"ops":[{"type":3,"author":{"id":"865bf723a9214027b17304fed4f98ae83e229e6421297d65bb8ed683dbeaeb5d"},"timestamp":1556064983,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQ4NjAyMDAwMw==","github-url":"https://github.com/rurban/smhasher/issues/65#issuecomment-486020003"},"nonce":"618YDRNlIHA8wSKZ/BnTuvq0KBQ=","message":"\u003e The fail of the test means that the seed is not fully diffused. \n\nI thought we already had a \"seed\" test ?\nhttps://github.com/rurban/smhasher/blob/master/main.cpp#L980 \n\n\u003e The detailed method is shown in the code.\n\nI wouldn't mind an explanation.\n\nMy understanding of this code is that it counts the nb of bits changed between 2 consecutive hashes, and uses that as a proxy for distribution quality (without even bothering about exact positions). Then, it magnifies this value by applying a power 5, and then sum them. \nSo now, thanks to the power 5, only the largest `popcount` values matter, the smaller ones doesn't. \nWhat the test effectively checks is if the nb of `popcount==31` and `popcount==30` is exactly the same, since any minor difference in these categories will have a huge impact. Then differences in smaller categories, such as `popcount\u003c10`, do not matter.\n\nIn which ways does this test check if the impact of the `seed` value is \"diffuse\" ?\n\n\u003e any statistics applied to hash(key,seed) should have similar behavier when applied to hash(seed,key).  (...) The fail of the test means that the seed is not fully diffused. \n\nI don't understand the link between the 2 statements.\n\nOne can easily imagine a hash algorithm where the impact of `seed+1` and `key+1` are entirely different, yet both fully diffuse. Why should they be interchangeable, up to their impact on the hash statistics ? This basically requires input to use a commutative form like `seed+key` or `seed^key` or `seed*key`, and specifically for the case where `len(input)==len(seed)`. That might be great for a prng, but I fail to appreciate how this design restriction benefits a hash.\n\n#### Is that about measuring the quality of seed diffusion ?\n\nIf the goal is to ensure that the impact of the seed is fully diffused, then the distribution impact of the `seed` should be fully analyzed, and independently. There's no point in comparing its statistics with something else. They could actually be both exactly as bad, that wouldn't make the `seed` fully diffuse.\n\nAnd that's exactly what the `seed` test does btw, as it uses exactly the same distribution test as all the other tests in the test suite.\n\nOne way to improve this test could be to run it at multiple input lengths (say, for example, 3, 8, 16, 32, 64, 128, 256), so that the result is not attached to a single specific length. That would be desirable as nowadays the seed can be treated differently depending on the input size.","files":null},{"type":6,"author":{"id":"865bf723a9214027b17304fed4f98ae83e229e6421297d65bb8ed683dbeaeb5d"},"timestamp":1556065704,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDIxMzY5OTk1Nw=="},"nonce":"WiQuw075XBvqfMgf2RJfVl46AdE=","target":"75f8550e9e3fe23ef40c0799f851a14e141dd03444558864c5e1f2d89318b7e9","message":"\u003e The fail of the test means that the seed is not fully diffused. \n\nI thought we already had a \"seed\" test ?\nhttps://github.com/rurban/smhasher/blob/master/main.cpp#L980 \n\n\u003e The detailed method is shown in the code.\n\nI wouldn't mind an explanation.\n\nMy understanding of this code is that it counts the nb of bits changed between 2 consecutive hashes, and uses that as a proxy for distribution quality (without even bothering about exact positions). Then, it magnifies this value by applying a power 5, and then sum them. \nSo now, thanks to the power 5, only the largest `popcount` values matter, the smaller ones doesn't. \nWhat the test effectively checks is if the nb of `popcount==31` and `popcount==30` is exactly the same, since any minor difference in these categories will have a huge impact. Then differences in smaller categories, such as `popcount\u003c10`, do not matter.\n\nI really fail to see how this test grabs the diffusion impact of the `seed` value.\n\n\u003e any statistics applied to hash(key,seed) should have similar behavier when applied to hash(seed,key).  (...) The fail of the test means that the seed is not fully diffused. \n\nI don't understand the link between the 2 statements.\n\nOne can easily imagine a hash algorithm where the impact of `seed+1` and `key+1` are entirely different, yet both fully diffuse. Why should they be interchangeable, up to their impact on the hash statistics ? This basically requires input to use a commutative form like `seed+key` or `seed^key` or `seed*key`, and specifically for the case where `len(input)==len(seed)`. That might be great for a prng, but I fail to appreciate how this design restriction benefits a hash.\n\n#### Is that about measuring the quality of seed diffusion ?\n\nIf the goal is to ensure that the impact of the seed is fully diffused, then the distribution impact of the `seed` should be fully analyzed, and independently. There's no point in comparing its statistics with something else. They could actually be both exactly as bad, that wouldn't make the `seed` fully diffuse.\n\nAnd that's exactly what the `seed` test does btw, as it uses exactly the same distribution test as all the other tests in the test suite.\n\nOne way to improve this test could be to run it at multiple input lengths (say, for example, 3, 8, 16, 32, 64, 128, 256), so that the result is not attached to a single specific length. That would be desirable as nowadays the seed can be treated differently depending on the input size.","files":null},{"type":6,"author":{"id":"865bf723a9214027b17304fed4f98ae83e229e6421297d65bb8ed683dbeaeb5d"},"timestamp":1556065754,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDIxMzcwMDE0Mw=="},"nonce":"4irajh1QCDpGCUOqdCnT6g6jMlc=","target":"75f8550e9e3fe23ef40c0799f851a14e141dd03444558864c5e1f2d89318b7e9","message":"\u003e The fail of the test means that the seed is not fully diffused. \n\nI thought we already had a \"seed\" test ?\nhttps://github.com/rurban/smhasher/blob/master/main.cpp#L980 \n\n\u003e The detailed method is shown in the code.\n\nI wouldn't mind an explanation.\n\nMy understanding of this code is that it counts the nb of bits changed between 2 consecutive hashes, and uses that as a proxy for distribution quality (without even bothering about exact positions). Then, it magnifies this value by applying a power 5, and then sum them. \nSo now, thanks to the power 5, only the largest `popcount` values matter, the smaller ones doesn't. \nWhat the test effectively checks is if the nb of `popcount==31` and `popcount==30` is exactly the same, since any minor difference in these categories will have a huge impact. Then differences in smaller categories, such as `popcount\u003c10`, do not matter.\n\nI really fail to see how this test grabs the diffusion impact of the `seed` value.\n\n\u003e any statistics applied to hash(key,seed) should have similar behavier when applied to hash(seed,key).  (...) The fail of the test means that the seed is not fully diffused. \n\nI don't understand the link between the 2 statements.\n\nOne can easily imagine a hash algorithm where the impact of `seed+1` and `key+1` are entirely different, yet both fully diffuse. Why should they be interchangeable, up to their exact impact on hash statistics ? This basically requires input to use a commutative form like `seed+key` or `seed^key` or `seed*key`, and specifically for the case where `len(input)==len(seed)`. That might be great for a prng, but I fail to appreciate how this design restriction benefits a hash.\n\n#### Is that about measuring the quality of seed diffusion ?\n\nIf the goal is to ensure that the impact of the seed is fully diffused, then the distribution impact of the `seed` should be fully analyzed, and independently. There's no point in comparing its statistics with something else. They could actually be both exactly as bad, that wouldn't make the `seed` fully diffuse.\n\nAnd that's exactly what the `seed` test does btw, as it uses exactly the same distribution test as all the other tests in the test suite.\n\nOne way to improve this test could be to run it at multiple input lengths (say, for example, 3, 8, 16, 32, 64, 128, 256), so that the result is not attached to a single specific length. That would be desirable as nowadays the seed can be treated differently depending on the input size.","files":null},{"type":6,"author":{"id":"865bf723a9214027b17304fed4f98ae83e229e6421297d65bb8ed683dbeaeb5d"},"timestamp":1556089110,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDIxMzgwNTA3Nw=="},"nonce":"2hq0l6/hEz+tsu8kn/sklamFBKA=","target":"75f8550e9e3fe23ef40c0799f851a14e141dd03444558864c5e1f2d89318b7e9","message":"\u003e The fail of the test means that the seed is not fully diffused. \n\nI thought we already had a \"seed\" test ?\nhttps://github.com/rurban/smhasher/blob/master/main.cpp#L980 \n\n\u003e The detailed method is shown in the code.\n\nI wouldn't mind an explanation.\n\nMy understanding of this code is that it counts the nb of bits changed between 2 consecutive hashes, and uses that as a proxy for distribution quality (without even bothering about exact positions). Then, it magnifies this value by applying a power 5, and then sum them. \nSo now, thanks to the power 5, only the largest `popcount` values matter, the smaller ones doesn't. \nWhat the test effectively checks is if the nb of largest `popcount` values are exactly the same, since any sublte difference in these categories will have a huge impact. Then differences in smaller categories, such as `popcount\u003c10`, do not matter.\n\nI really fail to see how this test grabs the diffusion impact of the `seed` value.\n\n\u003e any statistics applied to hash(key,seed) should have similar behavier when applied to hash(seed,key).  (...) The fail of the test means that the seed is not fully diffused. \n\nI don't understand the link between the 2 statements.\n\nOne can easily imagine a hash algorithm where the impact of `seed+1` and `key+1` are entirely different, yet both fully diffuse. Why should they be interchangeable, up to their exact impact on hash statistics ? This basically requires input to use a commutative form like `seed+key` or `seed^key` or `seed*key`, and specifically for the case where `len(input)==len(seed)`. That might be great for a prng, but I fail to appreciate how this design restriction benefits a hash.\n\n#### Is that about measuring the quality of seed diffusion ?\n\nIf the goal is to ensure that the impact of the seed is fully diffused, then the distribution impact of the `seed` should be fully analyzed, and independently. There's no point in comparing its statistics with something else. They could actually be both exactly as bad, that wouldn't make the `seed` fully diffuse.\n\nAnd that's exactly what the `seed` test does btw, as it uses exactly the same distribution test as all the other tests in the test suite.\n\nOne way to improve this test could be to run it at multiple input lengths (say, for example, 3, 8, 16, 32, 64, 128, 256), so that the result is not attached to a single specific length. That would be desirable as nowadays the seed can be treated differently depending on the input size.","files":null}]}