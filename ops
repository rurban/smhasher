{"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"ops":[{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598178519,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY3ODc1Njg4MQ==","github-url":"https://github.com/rurban/smhasher/issues/139#issuecomment-678756881"},"nonce":"wIerNjCNOwcEjYhecnd/zLsX9hs=","message":"But the implementation is incorrect in your bitfreq branch. If they fail given a correct counting implementation, it means their bit frequencies are not normally-distributed, they are far from what good random number generators.","files":null},{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598178546,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzk1MDUyODU5"},"nonce":"8zycctjg33GWt7t8mk5ku0n8MFY=","target":"4fd554307013550cc5569801e8ed8540b2f7abfd57c042bee9456200b9fd83d4","message":"But the implementation is incorrect in your bitfreq branch. If they fail given a correct counting implementation, it means their bit frequencies are not normally-distributed, they are far from what good random number generators produce.","files":null},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598179046,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY3ODc1NzY3Nw==","github-url":"https://github.com/rurban/smhasher/issues/139#issuecomment-678757677"},"nonce":"+GSSXitjuMBxToiHZzUPoqmsGH0=","message":"Instead of using `fabs( 1.0 - dev )` estimate, use simply `dev` estimate, and do not fail the test in any outcome: simply print if dev\u003c0.7: `too uniform`; if dev\u003e1.3: `non-uniform`; if fabs( 1.0 - dev )\u003c0.1: `perfect`.","files":null},{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598179082,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzk1MDUzMzAw"},"nonce":"rEec65CAPcYIjgx9c7IIbvHg9n8=","target":"8672898e9225cf7d14f0db61b4e258ca7e853fcadcd963211adf3c44c5598d58","message":"Instead of using `fabs( 1.0 - dev )` estimate, use simply `dev` estimate, and do not fail the test in any outcome: simply print if dev\u003c0.7: `too uniform`; if dev\u003e1.3: `non-uniform`; if fabs( 1.0 - dev )\u003c0.1: `perfect`, otherwise `good`.","files":null},{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598179200,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzk1MDUzMzc3"},"nonce":"i1lEOER+5N6cyl41W4B6bPUdDmo=","target":"8672898e9225cf7d14f0db61b4e258ca7e853fcadcd963211adf3c44c5598d58","message":"Instead of using `fabs( 1.0 - dev )` estimate, use simply `dev` estimate, and do not fail the test in any outcome: simply print if dev\u003c0.7: `overly uniform`; if dev\u003e1.3: `non-uniform`; if fabs( 1.0 - dev )\u003c0.1: `perfect`, otherwise `good`.","files":null},{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598179347,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzk1MDUzNTA5"},"nonce":"0hq0U2seaT5pYpJ9PYanY0xOUCA=","target":"8672898e9225cf7d14f0db61b4e258ca7e853fcadcd963211adf3c44c5598d58","message":"Instead of using `fabs( 1.0 - dev )` estimate, use simply `dev` estimate, and do not fail the test in any outcome: simply print if dev\u003c0.75: `overly uniform`; if dev\u003e1.25: `non-uniform`; if fabs( 1.0 - dev )\u003c0.1: `perfect`, otherwise `good`.","files":null},{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598179411,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzk1MDUzNTUx"},"nonce":"R9/NoLRTUeyhVwy12aKsHnIjO0k=","target":"8672898e9225cf7d14f0db61b4e258ca7e853fcadcd963211adf3c44c5598d58","message":"Instead of using `fabs( 1.0 - dev )` estimate, use simply `dev` estimate, and do not fail the test in any outcome: simply print if dev\u003c0.7: `overly uniform`; if dev\u003e1.3: `non-uniform`; if fabs( 1.0 - dev )\u003c0.1: `perfect`, otherwise `good`.","files":null},{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598179427,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzk1MDUzNTY1"},"nonce":"wm4QtIYpbWvYeBcGEx5hGPUPFZI=","target":"8672898e9225cf7d14f0db61b4e258ca7e853fcadcd963211adf3c44c5598d58","message":"Instead of using `fabs( 1.0 - dev )` estimate, use simply `dev` estimate, and do not fail the test in any outcome: simply print if dev\u003c0.7: `overly uniform`; if dev\u003e1.3: `non-uniform`; if fabs( 1.0 - dev )\u003c0.15: `perfect`, otherwise `good`.","files":null},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598179331,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY3ODc1ODA5Mg==","github-url":"https://github.com/rurban/smhasher/issues/139#issuecomment-678758092"},"nonce":"VCqKrJgn71i2pLUCTXtcSEl3RC8=","message":"This estimate is useful at proving cryptographic properties. `perfect` and `good` are cryptographic quality.","files":null},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598198825,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY3ODc5MjQ3Nw==","github-url":"https://github.com/rurban/smhasher/issues/139#issuecomment-678792477"},"nonce":"m7kQC+vAa094vhy4hK2THU6Yt9c=","message":"This commit is still incorrect. The part:\n```\nhashtype hashval;\n  hash(text,len,seed,\u0026hashval);\n\n  memset (counts, 0, sizeof (counts));\n  for( int j = 0; j \u003c sizeof(hashtype); j++ )\n  {\n    uint8_t b;\n    memcpy (\u0026b, \u0026hashval, 1);\n    counts[ b ]++;\n    hashval \u003e\u003e= 8;\n  }\n```\nshould be inside the `for (uint32_t seed = 0; seed \u003c 1\u003c\u003c31; seed += 8) {}` loop. Everything else should be outside of this loop.","files":null},{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598198844,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzk1MDcyNzEw"},"nonce":"h3LPGn6tt+Gmn6SeCcoR6suEYIg=","target":"554e490ca05646cf40a30a11271939d4c27f0a9b8e54608ed6a0e8e3787b8db5","message":"This commit is still incorrect. The part:\n```\nhashtype hashval;\n  hash(text,len,seed,\u0026hashval);\n\n  for( int j = 0; j \u003c sizeof(hashtype); j++ )\n  {\n    uint8_t b;\n    memcpy (\u0026b, \u0026hashval, 1);\n    counts[ b ]++;\n    hashval \u003e\u003e= 8;\n  }\n```\nshould be inside the `for (uint32_t seed = 0; seed \u003c 1\u003c\u003c31; seed += 8) {}` loop. Everything else should be outside of this loop.","files":null},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1598320793,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY3OTQ1NzI3Ng==","github-url":"https://github.com/rurban/smhasher/issues/139#issuecomment-679457276"},"nonce":"AIaQt92+wtvN7e47lkZtAybW4ZE=","message":"@rurban Note that in BitFreq branch you are applying the test to Seed parameter variation. So, this test will only tell how much the hash function is good as a random number generator. The same `bitfreq` test is best applied to the proposed `sparse long` and `Words` tests as well.","files":null},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1599020531,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY4NTI4NTM3OQ==","github-url":"https://github.com/rurban/smhasher/issues/139#issuecomment-685285379"},"nonce":"C6wZADak7Tg/yizXf43cx/424CM=","message":"@rurban Here is a lot better normalcy estimator. I think all good hash functions pass it anyway, but `fabs( devsq - 1.0 )` has a lot stricter range here, values \u003e0.15 is a fail.\n```\ninit:\n\tconst int BitPoolSizeX = 10;\n\tconst int BitPoolSize = 1 \u003c\u003c BitPoolSizeX;\n\tconst int BitPoolSizeMask = BitPoolSize - 1;\n\tuint64_t BitCounts[ BitPoolSize ] = { 0 };\n\tint BitPoolPos = 0;\n\nupdate:\n\t\tint j;\n\n\t\tfor( j = 0; j \u003c HashLen; j++ )\n\t\t{\n\t\t\tuint8_t v = Hash[ j ];\n\t\t\tint k;\n\n\t\t\tfor( k = 0; k \u003c 8; k++ )\n\t\t\t{\n\t\t\t\tBitCounts[ BitPoolPos ] += v \u0026 1;\n\t\t\t\tBitPoolPos = ( BitPoolPos + 1 ) \u0026 BitPoolSizeMask;\n\t\t\t\tv \u003e\u003e= 1;\n\t\t\t}\n\t\t}\n\nfinal:\n\tuint64_t AvgI = 0;\n\n\tfor( i = 0; i \u003c BitPoolSize; i++ )\n\t{\n\t\tAvgI += BitCounts[ i ];\n\t}\n\n\tdouble Avg = (double) AvgI / BitPoolSize;\n\tdouble devsq = 0.0;\n\n\tfor( i = 0; i \u003c BitPoolSize; i++ )\n\t{\n\t\tconst double d = BitCounts[ i ] / Avg - 1.0;\n\t\tdevsq += d * d;\n\t}\n\n\tdevsq *= 2.0 * Avg / BitPoolSize;\n```","files":null},{"type":3,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1599536512,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY4ODYwMDU2Ng==","github-url":"https://github.com/rurban/smhasher/issues/139#issuecomment-688600566"},"nonce":"w5hdH07B+tbUzjZshNa0VuGRDNE=","message":"@rurban Here's a lot better variant, works better since bit buffer length is a prime number.\n\ninit:\n\tconst int BitPoolSize = 1021;\n\tuint64_t BitCounts[ BitPoolSize ] = { 0 };\n\tint BitPoolPos = 0;\n\nupdate:\n\t\tint j;\n\n\t\tfor( j = 0; j \u003c HashLen; j++ )\n\t\t{\n\t\t\tuint8_t v = Hash[ j ];\n\t\t\tint k;\n\n\t\t\tfor( k = 0; k \u003c 8; k++ )\n\t\t\t{\n\t\t\t\tBitCounts[ BitPoolPos ] += v \u0026 1;\n\t\t\t\tBitPoolPos++;\n\t\t\t\t\n\t\t\t\tif( BitPoolPos == BitPoolSize )\n\t\t\t\t{\n\t\t\t\t\tBitPoolPos = 0;\n\t\t\t\t}\n\n\t\t\t\tv \u003e\u003e= 1;\n\t\t\t}\n\t\t}","files":null},{"type":6,"author":{"id":"656dd67b0f9bdf8bc451c83ff8f36ef959de2c8b4781d218d9958f9e71ef0639"},"timestamp":1599536532,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzk4NDU1NzU4"},"nonce":"I6NkLhjGObYg6Eto2yVgppdaL7M=","target":"e65bfdf3e70819bfaac7d89e49757a1adee262f0d40a78592c4d31844706f097","message":"@rurban Here's a lot better variant, works better since bit buffer length is a prime number.\n```\ninit:\n\tconst int BitPoolSize = 1021;\n\tuint64_t BitCounts[ BitPoolSize ] = { 0 };\n\tint BitPoolPos = 0;\n\nupdate:\n\t\tint j;\n\n\t\tfor( j = 0; j \u003c HashLen; j++ )\n\t\t{\n\t\t\tuint8_t v = Hash[ j ];\n\t\t\tint k;\n\n\t\t\tfor( k = 0; k \u003c 8; k++ )\n\t\t\t{\n\t\t\t\tBitCounts[ BitPoolPos ] += v \u0026 1;\n\t\t\t\tBitPoolPos++;\n\t\t\t\t\n\t\t\t\tif( BitPoolPos == BitPoolSize )\n\t\t\t\t{\n\t\t\t\t\tBitPoolPos = 0;\n\t\t\t\t}\n\n\t\t\t\tv \u003e\u003e= 1;\n\t\t\t}\n\t\t}\n```","files":null}]}