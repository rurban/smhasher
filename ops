{"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"ops":[{"type":1,"author":{"id":"78b38277b0a277d227658408146dcac1d0302d884545f4d0d36dc836990c6959"},"timestamp":1572274240,"metadata":{"github-id":"MDU6SXNzdWU1MTMzNTQwNDE=","github-url":"https://github.com/rurban/smhasher/issues/75","origin":"github"},"nonce":"wsUuoGIAiA9rkp+D9FQ0bRbdx/I=","title":"cross page boundary (Hash_Pippip)","message":"Your algorithm can cross a MMU page boundary and can produce general protection fault.\n\nAs option I propose this (a bit modified FNV1a):\n\nuint32_t fnv_1a(const char* key, size_t len)\n{\n    uint32_t hash32 = 2166136261;\n    const uint32_t PRIME = 1607;\n\n    for (size_t cnt = len / sizeof(uint32_t); cnt--; key += sizeof(uint32_t))\n        hash32 = (hash32 ^ (*(uint32_t*)key)) * PRIME;\n\n    if (len \u0026 sizeof(uint16_t)) {\n        hash32 = (hash32 ^ (*(uint16_t*)key)) * PRIME;\n        key += sizeof(uint16_t);\n    }\n    if (len \u0026 1)\n        hash32 = (hash32 ^ (*key)) * PRIME;\n\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}","files":null}]}