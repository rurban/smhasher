{"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"ops":[{"type":3,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1473067901,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0NDcwMjM0OQ==","github-url":"https://github.com/rurban/smhasher/issues/17#issuecomment-244702349"},"nonce":"AFDFA8ATN6rNPLsUd+DKTRXfHRc=","message":"With some state known, i.e. the collisions or the traversal order it's easy. E.g. https://jheusser.github.io/2013/02/03/satcoin.html for SHA-256 with several solvers, and also see the links in the References section. Esp. with cbmc. Formerly people encoded it into smtlib or z3, which was quite some work.\n\nYou don't attack the hash function per se, you attack the hash table state to get the seed and then produce the collisions brute force. With a small table size you get a lot of easy to find collisions. Only ~10 rightmost bits needed.","files":null},{"type":3,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1473068370,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0NDcwNDEzOA==","github-url":"https://github.com/rurban/smhasher/issues/17#issuecomment-244704138"},"nonce":"h9P2nTTi/Jsd75WM0mJLDGN3O58=","message":"\u003e If two keys in the hash table give bit-to-bit identical hashes, the hash table implementation has to use strcmp() or similar to compare the entire key byte-by-byte. This will result in O(n^2) work with regards to the size of the input keys. This is bad when hashing HTTP request headers or other untrusted data.\n\nYou can never trust the 32bit hash, you always have to compare the length and full keys with strcmp or better memcmp. Trusting a 32bit hash or anything \u003c256 would be foolish.\n\nAnd yes, this is bad. That's why fast HTTP parsers use better tricks than hash lookups. They usually look at the first 32 or 64bit word and cmp that in one instruction.\nHTTP headers can be handled by perfect hashes much better.","files":null}]}