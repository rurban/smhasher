{"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"ops":[{"type":3,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1483626846,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI3MDY1NzUxMQ==","github-url":"https://github.com/rurban/smhasher/issues/20#issuecomment-270657511"},"nonce":"1v8vS11e01o+NJkVzazcRnVkAzE=","message":"Maybe read also http://perl11.org/blog/seed.html and see my offline test https://github.com/perl11/cperl/blob/master/t/op/hashflood.t and https://github.com/perl11/cperl/blob/master/t/op/seed-siphash-8-0.dat (and other collision files for more hash funcs) created in 0.003s per seed.\n\nI won't disclose much further how to get at a seed practically, as most dynamic languages are affected who rely on the false siphash security claims.\n\nad 2. you don't need to send million keys, just as many to be able time the differences to identify collisions. 8bit should be enough locally (255 keys) with brute-force of 0.003s for siphash.\nexternally you might need 16bit (65535 keys) with brute-force time of 1m30s (fast) vs 2m (siphash).\n\nad 5. even SHA-1 is insecure and statistically bad when used in a 32bit hash table, as seen in the smhasher tests. I won't trust a crippled SHA-2 nor SHA-3 neither, but haven't tested it yet.\n\nad 6. collisions are trivial to generate for every single hash function used in hash tables. if siphash, sha-1 or more. just brute force it for the usual hash table schemes (will not work with better ones using primes). siphash just needs twice as long, as the primary factor in siphash is mixing the seed into the box and slowness. \n\njust getting the siphash seed is not as trivial as for most other hash funcs. \nwatch the relevant CCC talk https://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html (against trivial DJBX33A/DJBX33X style hashes) and https://events.ccc.de/congress/2012/Fahrplan/events/5152.en.html (siphash), where most hash funcs were broken and the secure hash function myth started.","files":null},{"type":3,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1483627012,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI3MDY1ODEwMg==","github-url":"https://github.com/rurban/smhasher/issues/20#issuecomment-270658102"},"nonce":"3IntTo0owosVk9nTtWcBXqOioPM=","message":"```\n  This number depends on the measureable timing of collisions:\n  BITS=10: N=1023 colliding buckets, to expose timings in linear search\n    - O(n/2) vs O(1)\n  Search in a linked list of 16383 should be enough to DoS a server (created in 7s)\n  but creating big lists need only 2-4min, independent on the keys.\n  Typical POST size 1-4MB enough, PHP limits to max 1000 keys (i.e. 11 bits)\n  time to create is trivial brute-force, not with a solver yet.\n  Here with the slowest hash: siphash. others are almost twice as fast.\n\n   BITS N          time (siphash)  fnv1a\n   8  - 255        0.003s\n   9  - 511        0.006s\n   10 - 1023       0.033s\n   11 - 2047       0.12s\n   12 - 4095       0.45s\n   13 - 8191       1.82s\n   14 - 16383      7.6s\n   15 - 32767      31s\n   16 - 65535      2m2s            1m30s\n   18 - 262143     4m3s 23770      2m38s found 49446\n   20 - 1048575    3m44s           2m37s\n                   9m42 16135\n                   3m57 6367\n   24 - 16777215   3m55s (heap-array, stack too small)\n   28 - 268435455  3m57s           2m42s\n   31 - 2147483647                 2m40s\n```","files":null},{"type":5,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1499701566,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDExNTcwNjk1Njc="},"nonce":"rQfFn3Hu4y1yd2uGmv9sOYNzudw=","added":["enhancement"],"removed":[]}]}