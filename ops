{"author":{"id":"dea43e6b916975bf3cff4424f473a805c833f29424f086ee359d4eb329d3da27"},"ops":[{"type":3,"author":{"id":"dea43e6b916975bf3cff4424f473a805c833f29424f086ee359d4eb329d3da27"},"timestamp":1586265755,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYxMDM4MzUwMw==","github-url":"https://github.com/rurban/smhasher/issues/116#issuecomment-610383503"},"nonce":"Z0EEvGjKHPaxtMNSpF1ytndW7Ys=","message":"\u003ethe speed result is not from smhasher, but from my own benchmark.cpp which is inlining.\n\nI'm asking, because it seems without inlining (e.g. in smhasher), the speed difference for small keys won't be that significant, but the bulk speed will be significantly lower than the others - that would indicate wyhash being less useful than before.\n\nOn the other hand I know there is [the effort](https://github.com/rurban/smhasher/issues/76#issuecomment-555552902 ) to support inlining advantages for certain hashes, but for now I'd really stick to a fair smhasher comparison :wink:.\n\n\u003ethe only trick is the \"one-shot reads\" learnt from t1ha. it reads passed buffer boundaries, both before and after, up to 8 byte. but with shifts, it passed smhasher sainity check. Also from other users, a define is avalible to use conventional safe reads.\n\nI don't think boundaries are thoroughly being checked for sanity in smhasher (as it wasn't a concern with majority of existing hash functions) - therefore I pointed it out.\n\n\u003eAlso from other users, a define is avalible to use conventional safe reads.\n\nOh, cool you re-introduced the condom again. Thanks! Yesterday it wasn't there yet and the whole code didn't look finished.\n\nCould you re-run smhasher tests and speed tests with the condom to see the speed and quality differences?","files":null}]}