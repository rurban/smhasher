{"author":{"id":"ef11ab78f8eb46f13a7f7a9fd6542e1122505a7012e84ff39a5ae98abbc5839d"},"ops":[{"type":1,"author":{"id":"ef11ab78f8eb46f13a7f7a9fd6542e1122505a7012e84ff39a5ae98abbc5839d"},"timestamp":1472990571,"metadata":{"github-id":"MDU6SXNzdWUxNzQ5NDU1MjA=","github-url":"https://github.com/rurban/smhasher/issues/17","origin":"github"},"nonce":"8B8ysKXX2bjIp3s1pjz/JiG5oq4=","title":"About the security claims in README","message":"I'm not convinced that the claims about resistance to \"hash flooding\" algorithmic complexity DDoS attacks in the SECURITY chapter of README.md are correct. I'll address some of the claims.\n\n\u003e Such an attack avoidance cannot not be the problem of the hash function, but the hash table collision resolution scheme.\n\nThe hash table collision resolution scheme does affect the performance but does not address the O(n) issues with hash collisions. A good resolution scheme can only help when (hash % tablesize) is equal between two hashes, but the hashes are not equal.\n\nIf two keys in the hash table give bit-to-bit identical hashes, the hash table implementation has to use strcmp() or similar to compare the entire key byte-by-byte. This will result in O(n^2) work with regards to the size of the input keys. This is bad when hashing HTTP request headers or other untrusted data.\n\nThis issue is made worse in the very simple hash functions because it's trivial to create hash collisions by appending a few bytes to the end of a key and strcmp() can't early exit before scanning the whole input.\n\n\u003e  You can attack every single hash function, even the best and most secure if you detect the seed\n\nIndeed, the motivation for SipHash is to make recovering the key from timing information (or other side channels) difficult. It's the only hash function that I could find with any credible, peer-reviewed cryptanalysis on key recover.\n\nToo bad that SipHash is pretty slow (2000 MB/s on my Skylake, the SSE2, SSSE3 and AVX2 implementations were slower) due to poor instruction level parallelism caused by explicit dependencies between instructions (in particular when implemented with SIMD). There are hash functions in smhasher that perform 5x to 15x faster than that.\n\nIf anyone is aware of any better performing hash functions that have been designed and analyzed with key recovery difficulty in mind, please do share.\n\nPlease discuss.","files":null}]}