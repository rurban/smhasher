{"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"ops":[{"type":3,"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"timestamp":1572871825,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU0OTMzODc4Nw==","github-url":"https://github.com/rurban/smhasher/issues/76#issuecomment-549338787"},"nonce":"8dh7WoXwRbXqzf92/XL5Tm4k/Yk=","message":"Reini,\nplease consider removing the old ones: 'FNV1a_YT' and 'FNV1A_Totenschiff'.\nMy wish is to see the latest and strongest, only, which is 'FNV1A_Pippip_Yurii', at:\nhttps://www.codeproject.com/Articles/716530/Fastest-Hash-Function-for-Table-Lookups-in-C\n\n@dumblob\nSure, but I still have no framework - just random benchmarks, very informative, though. It would be nice to gather the scattered speed and collision benchmarks into one package...\n\nAt the moment, had time to run only Yann's speed benchmark v0.7.2 on my i5-7200U:\n\nI added to 'hashes.h':\n\n```\n#include \"wyhash.h\"\n\n// Kaze was here\n#include \u003cstdint.h\u003e // uint8_t needed\n#define _PADr_KAZE(x, n) ( ((x) \u003c\u003c (n))\u003e\u003e(n) )\n// Many thanks go to Yurii 'Hordi' Hordiienko, he lessened with 3 instructions the original 'Pippip', thus:\n//#include \u003cstdlib.h\u003e\n//#include \u003cstdint.h\u003e\nuint32_t FNV1A_Pippip_Yurii(const char *str, size_t wrdlen) {\n\tconst uint32_t PRIME = 591798841; uint32_t hash32; uint64_t hash64 = 14695981039346656037;\n\tsize_t Cycles, NDhead;\nif (wrdlen \u003e 8) {\n\tCycles = ((wrdlen - 1)\u003e\u003e4) + 1; NDhead = wrdlen - (Cycles\u003c\u003c3);\n        for(; Cycles--; str += 8) {\n\t\thash64 = ( hash64 ^ (*(uint64_t *)(str)) ) * PRIME;        \n\t\thash64 = ( hash64 ^ (*(uint64_t *)(str+NDhead)) ) * PRIME;        \n\t}\n} else\n\thash64 = ( hash64 ^ _PADr_KAZE(*(uint64_t *)(str+0), (8-wrdlen)\u003c\u003c3) ) * PRIME;        \nhash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32)); return hash32 ^ (hash32 \u003e\u003e 16);\n} // Last update: 2019-Oct-30, 14 C lines strong, Kaze.\n\nsize_t FNV1A_Pippip_Yurii_wrapper(const void* src, size_t srcSize, void* dst, size_t dstCapacity, void* customPayload)\n{\n    (void)dst; (void)dstCapacity; (void)customPayload;\n    return (size_t) FNV1A_Pippip_Yurii(src, srcSize);\n}\n\nsize_t wyhash_wrapper(const void* src, size_t srcSize, void* dst, size_t dstCapacity, void* customPayload)\n{\n    (void)dst; (void)dstCapacity; (void)customPayload;\n    return (size_t) wyhash(src, srcSize, 0);\n}\n```\n\nBy the way, if anyone has machine with 32GB then we all can witness one superb benchmark - Lookuperorama (featuring WYHASHv3 and XXH3) testing CIHAI - 'Sea of Words', the treasure of Chinese language 22,000,000 hieroglyphs strong. Just let me know, will share the package.\n\nAnd, could someone explain why the big difference between different metrics:\n\n```\nkey size            wyhash    XXH_SCALAR\nsmall:cycles/hash   13.070    18.293\n```\nand\nhttps://software.intel.com/en-us/forums/intel-moderncode-for-parallel-architectures/topic/824947#comment-1947447\n\nAs always, the attached .ZIP package contains the sources, binary, MAKE.EXE.BAT and RUNME.BAT, don't know how most powerful Zen and Xeon processors run it!","files":null}]}