{"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"ops":[{"type":3,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1473108249,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI0NDgwOTQ4OQ==","github-url":"https://github.com/rurban/smhasher/issues/17#issuecomment-244809489"},"nonce":"FEmEZf0QKJfZBMN5UCQzUaOHygI=","message":"\u003e This is indeed the case and why hash tables with non-random keys or flaky characteristics should not be used on untrusted data.\n\nNo, with a proper hash table you can guarantee constant lookup even for the worst case. But the hash function has almost nothing to do with that. (besides uhash, which uses two random simple mult hash functions, simpler than FNV1)\n\n\u003e And it's the reason why Perl, Python, Ruby etc changed from DJB33*, FNV1 and other easy to attack hashes to SipHash. In your opinion, they could have picked any hash function (e.g. Murmur3) with a random seed?\n\nA random seed helps, but was not enough. SipHash does not help at all. It doesn't help security, it only makes it slower. The best is to forget about linear chaining. This is the real culprit.\nMurmur is also too big for hash tables.\nThe argument for linear chaining is faster splits (reallocation, double size), but there are still a lot of unneeded branches in this previously \"fast\" split code. It's easier to reuse the already calculated hash and just insert afresh.\n\n\u003e The attack on hash tables was based on easily being able to generate collisions, causing the http header hash table to hog the CPU memcmp'ing the key data while using very little network bandwidth.\n\nYes, I know the attacks. There are many similar scenarios. glibc, the linux kernel, most routers, dns resolvers, all use proper hash tables, which are mostly fast. To counter a DDOS just detect it, like collisions \u0026 (collisions % 16) and sleep a while. Or limit the attack vector as PHP did (MAX_POST_SIZE). Or randomize the iterator as Perl did to hide the seed (not a good idea, but still). collisions\u003e8 don't appear in the wild, unless you are using linear probing and a higher fill factor. Where the collisions are all in the cache and so it doesn't cost at all.\nOr use a secure and fast scheme. As explained.\n\n\u003e \u003e You don't attack the hash function per se, you attack the hash table state to get the seed and then produce the collisions brute force.\n\u003e \n\u003e Isn't this the reason why difficulty of key recovery is a characteristic of a good, secure hash function?\n\nA hash function cannot be secure by default. This is not possible with max 32bit, where only 7-10 bits are used to attack it.\n\n\u003e \u003e Crypto analysis on a 32bit hash function for seed recovery is not needed because you can trivially brute force it or solve it with a simple solver.\n\u003e \n\u003e You imply that generating collisions is trivial, and not dependent on the hash function. Can you link to an attack demonstrating this?\n\nNope. I don't have the time to write such a thing, academia or script kiddies will do sooner or later.\nI work on the other side, fixing hash tables which are resistant against worst cases, without doing too much harm to the performance.\n\n\u003e The satcoin example was intriguing, are you aware of this being applied to hash table DDoSing?\n\nNo. Just timing attacks and using solvers to create hash function collisions, currently MD5.\nDDOS is just a kids attack tool. We should not really care about those kind of DDOS attacks in the wild, as it is much easier to DDOS someone with simpler methods. It's a more a marketing argument.\n\n\u003e \u003e But here we are only talking about hash function security, and those silly and harmful claims need to be debunked.\n\u003e \n\u003e I guess this was why I opened this issue. The readme makes claims that counter research papers on the subject but don't cite any sources or give any background. You seem to be convinced that hash function security is a non-issue but could you back this up so it would be convincing to others too?\n\nIt's pure logic. 32bit hash functions cannot be called secure. They can only be broken or not, or fast or not. Siphash has a prominent name behind it, but this still doesn't defy common sense. And it does harm to all those dynamic languages using it.\n\nThere are also much more silly theories in hash tables in the wild, such as using primes for the size for better module distribution, esp. with open addressing. As in glibc and in the linux kernel. \n2^n exponential size is much better suited, as you can bitmask the hash index. A proper distribution just needs an uneven size (2^n - 1), and the numbers (the size and the hash internal constant) must be coprime. Which is trivial to guarantee.","files":null},{"type":4,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1474440667,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50Nzk2ODIzOTE3"},"nonce":"2Vbw6Dh12Bz9f7snbE0P9jL/ZFQ=","status":2}]}