{"author":{"id":"e157bef5b913129889bf0f749ce117e9e21ea8680628344c1940e51c472d3694"},"ops":[{"type":3,"author":{"id":"e157bef5b913129889bf0f749ce117e9e21ea8680628344c1940e51c472d3694"},"timestamp":1483478733,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI3MDIyOTA4NQ==","github-url":"https://github.com/rurban/smhasher/issues/20#issuecomment-270229085"},"nonce":"Yl/8qnlbLmATQy2ocBs98IGVf7I=","message":"I still think that there is a great misunderstanding on your side. Can you describe plan of such attack? flood resistance idea suppose that you send keys to another network node. So:\n\n1) even if you run two network processes on the same cpu, network I/O time (millions of msgs per second) is higher than hash computation time. So, no need to measure time of hash calculation, instead measure number of msgs you can send via particular network.\n\n2) hash tables don't have fixed size, thaty are extended to accomodate more entries. so, if you send million keys to the attacked node, you will definitely have a lot of 10-bit collisions, but the hash table will probably contain a million entries too.\n\n3) that is you plan to searching collisions? let's imagine that application developers are so kind that they give you a full collision list for the current table contents. so you send, at average, 32 keys and found 1 collision, then you deleted all non-collisioned keys and send, at average, another 1024 keys to find one more key resolving to the same hash entry, remove all extra keys and repeat that again. As you see, if hash table has 1024 entries, you need to send N*1024 keys to build a single entry with N colliding keys. It will work with any hash algorithm, so hash algos themself can't be judged on this critery. It's still true that good network application should be developed seriously and hash algo by itslef (even SHA) doesn't ensur—É security.\n\n4) that algos like siphash is try to ensure is that, without knowing seed, you can request any reasonable amount of key-\u003evalue mappings and still be unable to construct new keys mapping to values you choose (including subsets of value bits) with probablility larger than 2^-N, where N is width of value/subvalue. \n\n5) Secure hash algos like SHA-1/2/3 provides the same guarantees, even without seeding. And you can see that despite huge practical value, bitcoins are still mined either with brute-force approaches or at least with speed close to brute-forcing. So, no doubt that we can't yet generate 40+ bit SHA2 collisions much faster than brute-forcing\n\n6) For usual hashes, we know that collisions are easy to generate for xxhash32 and murmurhash3a. i haven't seen any work generating collisions w/o knowing seed with higher probability than 2^-N - for any other algorithm, including siphash, spookyhash and so on. So you need to decide - if you talk about attacks mathematically possible against any hash including SHA family, there is no way but carefully design network apps to deal with such attacks. If you say that you can find collisions with better than mathematically possible probability for any hash but xxh32/murmur3a, than we are all ears. Mixing those two types of attacks is just a way to muddy the waters","files":null}]}