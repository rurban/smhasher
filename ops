{"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"ops":[{"type":3,"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"timestamp":1570912707,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU0MTM1OTY0Ng==","github-url":"https://github.com/rurban/smhasher/issues/73#issuecomment-541359646"},"nonce":"QvgSfaqyYMePj/DE7RDxOiIpKV4=","message":"Reini, had time to play with it and realized it is causa perduta, so ... so long 32bit, here comes fastest known to me lookuper:\n\n```\n#include \u003cstdint.h\u003e // uint8_t needed\n#define _PADr_KAZE(x, n) ( ((x) \u003c\u003c (n))\u003e\u003e(n) )\n#define ROLInBits 27 // 5 in r.1; Caramba: it should be ROR by 5 not ROL, from the very beginning the idea was to mix two bytes by shifting/masking the first 5 'noisy' bits (ASCII 0-31 symbols).\n// CAUTION: Add 8 more bytes to the buffer being hashed, usually malloc(...+8) - to prevent out of boundary reads!\n#define _rotl64_KAZE(x, n) (((x) \u003c\u003c (n)) | ((x) \u003e\u003e (64-(n))))\nuint32_t FNV1A_Hash_Totenschiff_v1(const char *str, uint32_t wrdlen)\n{\n    const uint32_t PRIME = 591798841;\n    uint32_t hash32 = 2166136261;\n    uint64_t hash64 = 14695981039346656037;//2166136261;\n    const char *p = str;\n    uint64_t PADDEDby8;\n\n    for(; wrdlen \u003e 2*sizeof(uint32_t); wrdlen -= 2*sizeof(uint32_t), p += 2*sizeof(uint32_t)) {\n\t    PADDEDby8 = *(uint64_t *)(p+0);\n\t    hash64 = ( hash64 ^ PADDEDby8 ) * PRIME;        \n    }\n\n    // Here 'wrdlen' is 1..8\n    PADDEDby8 = _PADr_KAZE(*(uint64_t *)(p+0), (8-wrdlen)\u003c\u003c3); // when (8-8) the QWORD remains intact\n    hash64 = ( hash64 ^ PADDEDby8 ) * PRIME;        \n\n    hash32 = (uint32_t)(hash64 ^ (hash64\u003e\u003e32));\n    return hash32 ^ (hash32 \u003e\u003e 16);\n}\n```\n\nhttps://software.intel.com/en-us/forums/intel-moderncode-for-parallel-architectures/topic/824947#comment-1946638","files":null},{"type":3,"author":{"id":"382e0604a0cc648df6764230ea7ce0b626217738167eb2200238272b6c52e2a8"},"timestamp":1571094999,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU0MTk3MDExNA==","github-url":"https://github.com/rurban/smhasher/issues/73#issuecomment-541970114"},"nonce":"FrCvSkxJWg/SWciUdlD6wAdcT7M=","message":"I did what I could.\nI believe, FNV1A-Totenschiff dominates whenever small keys are to be hashed for lookup tables.\n\nhttps://software.intel.com/en-us/forums/intel-moderncode-for-parallel-architectures/topic/824947#comment-1946707","files":null}]}