{"author":{"id":"2839dde69e17de5fdb644773da784189cc39aab6c9cfd25d613f1d1f49845c96"},"ops":[{"type":3,"timestamp":1688118490,"metadata":{"github-id":"IC_kwDOARWYbc5gOf6e","github-url":"https://github.com/rurban/smhasher/issues/270#issuecomment-1614413470"},"nonce":"oA8EU+5rhN2S5k0FetT3cySf9eY=","message":"For reference, here's the code I used to create the infinite stream:\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003cfstream\u003e\n#include \u003cinttypes.h\u003e\n#include \u003cstdexcept\u003e\n#include \u003cstring\u003e\n#include \u003ccstring\u003e\n\n#include \"discohash.h\"\n\n#ifdef _WIN32\n#include \u003cio.h\u003e\n#include \u003cfcntl.h\u003e\n#define SET_BINARY_MODE(handle) _setmode(_fileno(handle), _O_BINARY)\n#else\n#define SET_BINARY_MODE(handle) ((void)0)\n#endif\n\nvoid readFileToBuffer(const std::string\u0026 filename, std::vector\u003cuint8_t\u003e\u0026 buffer) {\n  std::ifstream file(filename, std::ios::binary | std::ios::ate);\n  if (file.fail()) {\n    throw std::runtime_error(\"Unable to open the file: \" + filename);\n  }\n  std::streamsize size = file.tellg();\n  file.seekg(0, std::ios::beg);\n\n  buffer.resize(size, 0);\n\n  if (!file.read(reinterpret_cast\u003cchar*\u003e(buffer.data()), size)) {\n    throw std::runtime_error(\"Failed to read the file: \" + filename);\n  }\n}\n\nvoid readStdinToBuffer(std::vector\u003cuint8_t\u003e\u0026 buffer) {\n  alignas(uint64_t)std::istreambuf_iterator\u003cchar\u003e begin(std::cin), end;\n  alignas(uint64_t)std::vector\u003cchar\u003e inputChars(begin, end);\n  buffer = std::vector\u003cuint8_t\u003e(inputChars.begin(), inputChars.end());\n}\n\nint main(int argc, char **argv) {\n  alignas(uint64_t)std::vector\u003cuint8_t\u003e buffer;\n  std::string filename;\n  std::string outputFilename;\n  bool infiniteMode = false;\n  FILE* outputFile = stdout; // Default to stdout\n  int outputWords = 4;\n\n  // Handle flags and arguments\n  for (int i = 1; i \u003c argc; i++) {\n    if (strcmp(argv[i], \"--infinite\") == 0) {\n      infiniteMode = true;\n    } else if (strcmp(argv[i], \"--outfile\") == 0) {\n      if (i + 1 \u003c argc) {\n        outputFilename = argv[++i];\n        outputFile = fopen(outputFilename.c_str(), \"wb\");\n        if (!outputFile) {\n          std::cerr \u003c\u003c \"Error: Unable to open output file: \" \u003c\u003c outputFilename \u003c\u003c std::endl;\n          return EXIT_FAILURE;\n        }\n      } else {\n        std::cerr \u003c\u003c \"Error: --outfile option requires a filename argument.\" \u003c\u003c std::endl;\n        return EXIT_FAILURE;\n      }\n    } else if (strcmp(argv[i], \"--words\") == 0) {\n      if (i + 1 \u003c argc) {\n        outputWords = std::stoi(argv[++i]);\n        if (outputWords \u003c 1 || outputWords \u003e 4) {\n          std::cerr \u003c\u003c \"Error: --words option requires an integer between 1 and 4.\" \u003c\u003c std::endl;\n          return EXIT_FAILURE;\n        }\n      } else {\n        std::cerr \u003c\u003c \"Error: --words option requires an integer argument.\" \u003c\u003c std::endl;\n        return EXIT_FAILURE;\n      }\n    } else {\n      filename = argv[i];\n    }\n  }\n\n  if (infiniteMode \u0026\u0026 outputFile == stdout) {\n    SET_BINARY_MODE(stdout);\n  }\n\n  bool readFromFile = !filename.empty() \u0026\u0026 filename != \"-\";\n  if (readFromFile) {\n    readFileToBuffer(filename, buffer);\n  } else {\n    readStdinToBuffer(buffer);\n  }\n\n  // Buffer to store the hash output\n  std::vector\u003cuint64_t\u003e hash(4);\n\n  // Sponge construction\n  if (infiniteMode) {\n    std::vector\u003cuint8_t\u003e input = buffer;\n    while (true) {\n      BEBB4185_64(input.data(), input.size(), 0, hash.data());\n      std::fwrite(hash.data(), sizeof(uint64_t), 4, outputFile);\n      std::fflush(outputFile); // make sure it's written\n      // Reuse the same memory buffer as input for the next iteration\n      std::memcpy(input.data(), hash.data(), sizeof(uint64_t) * 4);\n    }\n  } else {\n    BEBB4185_64(buffer.data(), buffer.size(), 0, hash.data());\n    for (int i = 0; i \u003c outputWords; ++i) {\n      fprintf(outputFile, \"%016\" PRIx64, hash[i]);\n    }\n    fprintf(outputFile, \" %s\\n\", filename.c_str());\n  }\n\n  // Close the output file if it's not stdout\n  if (outputFile != stdout) {\n    fclose(outputFile);\n  }\n\n  return EXIT_SUCCESS;\n}\n```","files":null},{"type":3,"timestamp":1688118581,"metadata":{"github-id":"IC_kwDOARWYbc5gOgXm","github-url":"https://github.com/rurban/smhasher/issues/270#issuecomment-1614415334"},"nonce":"JzGBBqQgJvjLMBZiw1rFA2gTxk4=","message":"for illustration of exactly what i meant","files":null},{"type":3,"timestamp":1688118679,"metadata":{"github-id":"IC_kwDOARWYbc5gOg2W","github-url":"https://github.com/rurban/smhasher/issues/270#issuecomment-1614417302"},"nonce":"6A0Ia2XWeDlJj6IOlKmyq5ftcPA=","message":"then i'd run:\n\n```console\n$ gzip -vv -9 \u003coutfile\u003e\n```\n\nor\n\n```console\n$ lzma -9 -c -v \u003coutfile\u003e\n```","files":null},{"type":6,"timestamp":1688172783,"metadata":{"github-id":"UCE_lALOARWYbc5gOg2WzjObN4s"},"nonce":"f1g/TqTjJ68iB86M1GoBHOjL0Z4=","target":"58917e9a3f3a2d033a2d920061fbeb792801804e31728c0e0cef216b5d84b73f","message":"then i'd run:\n\n```console\n$ gzip -vv -9 \u003coutfile\u003e\n```\n\nor\n\n```console\n$ lzma -9 -z -v \u003coutfile\u003e\n```","files":null}]}