{"author":{"id":"1199fa5e4fbcf00c9729033551d31179d9bd0ccb2bf4254d5de08ad7b107728b"},"ops":[{"type":3,"author":{"id":"1199fa5e4fbcf00c9729033551d31179d9bd0ccb2bf4254d5de08ad7b107728b"},"timestamp":1514801738,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM1NDY0NjE4Nw==","github-url":"https://github.com/rurban/smhasher/issues/20#issuecomment-354646187"},"nonce":"lJuNBcBMaIEErlY1cGXqBzQ0GIk=","message":"Did you notice one of the \"take home messages\" of the [CCC talk linked](https://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html):\n\n\u003e Randomize your hash functions!\n\n(Also, the hash function attacked in that article, DJBX33X, is far from a secure hash function.)\n\nI don't know about any of the others, but this is exactly what Rust does, with a new key for every hash table. All the talk of secure hash functions being \"security theatre\" assumes the key is known or deducible. [This article](http://perl11.org/blog/seed.html) is even worse and could almost be summarized as: *given the ability to run arbitrary code on a server [plus some other requirements] we can run a CPU DoS attack* â€” well, this is pretty easy then, isn't it?\n\nIf anything the advice should be *use a secure hash function with a secure random key for every table, and never dump keys to log files or when serializing data*. Again, I can't talk for any other language, but this is exactly what Rust does.","files":null}]}