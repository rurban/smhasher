{"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"ops":[{"type":3,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1590343034,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDYzMzI2NzU2Mw==","github-url":"https://github.com/rurban/smhasher/issues/128#issuecomment-633267563"},"nonce":"461JoWr0VWAxPy50R973juVpyKE=","message":"There is an unmaintained fork, which supports better seeding lengths, esp for 64bit or even 128 and 256bits. But it's a lot of work to include that. See #31","files":null},{"type":6,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1590343388,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzc0MjU2Mjg2"},"nonce":"rlZ4BfrqNb+ot4yljD6ehg64vNI=","target":"5b5f941b0b063d761b734c6c482a20d213eb1505610a087c4083d890628a1706","message":"There is an unmaintained fork, which supports better seeding lengths, esp for 64bit or even 128 and 256bits. But it's a lot of work to include that. See #31 \nBut this is only for the length. Hashes which change seeds not that often, eg google's farmhash using internal pointers as seed, abusing ASLR or such are not well supported. \nThere I just skip the seed tests, by using 0 as verification value.\n\n100.000 cycles to change the seed is pretty crazy. It isn't counted in the tests, but timeouts should not happen. smhasher sets the seeds at once. Do you need to process the IV after each seed change that expensively?  There are a few hashes which need that, see the special cases in `Hash_init()`\nEsp. some crypto hashes.","files":null},{"type":6,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1590343526,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzc0MjU2NDQ5"},"nonce":"vAp0ZLwDqPuzaV2E0qoXD4kLJS8=","target":"5b5f941b0b063d761b734c6c482a20d213eb1505610a087c4083d890628a1706","message":"There is an unmaintained fork, which supports better seeding lengths, esp for 64bit or even 128 and 256bits. But it's a lot of work to include that. See #31 \nBut this is only for the length. Hashes which change seeds not that often, eg google's farmhash using internal pointers as seed, abusing ASLR or such are not well supported. \"Autoseeded\".\nThere I just skip the seed tests, by using 0 as verification value.\n\n100.000 cycles to change the seed is pretty crazy. It isn't counted in the tests, but timeouts should not happen. smhasher sets the seeds at once. Do you need to process the IV after each seed change that expensively?  There are a few hashes which need that, see the special cases in `Hash_init()`\nEsp. some crypto hashes.","files":null},{"type":6,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1590343581,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzc0MjU2NTA2"},"nonce":"WOs372UpqsswwO6LhStPbBADaD8=","target":"5b5f941b0b063d761b734c6c482a20d213eb1505610a087c4083d890628a1706","message":"There is an unmaintained fork, which supports better seeding lengths, esp for 64bit or even 128 and 256bits. But it's a lot of work to include that. See #31 . The longer the seed the better security.\nBut this is only for the length. \n\nHashes which change seeds not that often, eg google's farmhash using internal pointers as seed, abusing ASLR or such are not well supported. \"Autoseeded\".\nThere I just skip the seed tests, by using 0 as verification value.\n\n100.000 cycles to change the seed is pretty crazy. It isn't counted in the tests, but timeouts should not happen. smhasher sets the seeds at once. Do you need to process the IV after each seed change that expensively?  There are a few hashes which need that, see the special cases in `Hash_init()`\nEsp. some crypto hashes.","files":null},{"type":6,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1590343626,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzc0MjU2NTUy"},"nonce":"cHSMa0TTDnc58a+MdKY1lzvHQmw=","target":"5b5f941b0b063d761b734c6c482a20d213eb1505610a087c4083d890628a1706","message":"There is an unmaintained fork, which supports better seeding lengths, esp for 64bit or even 128 and 256bits. But it's a lot of work to include that. See #31 . The longer the seed the better security.\nBut this is only for the length. \n\nHashes which are self-seeded automatically, eg google's farmhash using internal pointers as seed, abusing ASLR or such are not well supported.\nThere I just skip the seed tests, by using 0 as verification value.\n\n100.000 cycles to change the seed is pretty crazy. It isn't counted in the tests, but timeouts should not happen. smhasher sets the seeds at once. Do you need to process the IV after each seed change that expensively?  There are a few hashes which need that, see the special cases in `Hash_init()`\nEsp. some crypto hashes.","files":null},{"type":6,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1590343647,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzc0MjU2NTY3"},"nonce":"gbun30BPh1Yjq3JJBCifZjdKlQw=","target":"5b5f941b0b063d761b734c6c482a20d213eb1505610a087c4083d890628a1706","message":"There is an unmaintained fork, which supports better seeding lengths, esp for 64bit or even 128 and 256bits. But it's a lot of work to include that. See #31 . The longer the seed the better security.\nBut this is only for the length. \n\nHashes which are self-seeded automatically, eg google's farmhash using internal pointers as seed, abusing ASLR or such are not well supported.\nThere I just skip the seed tests, by using 0 as verification value. It's a good strategy still.\n\n100.000 cycles to change the seed is pretty crazy. It isn't counted in the tests, but timeouts should not happen. smhasher sets the seeds at once. Do you need to process the IV after each seed change that expensively?  There are a few hashes which need that, see the special cases in `Hash_init()`\nEsp. some crypto hashes.","files":null},{"type":6,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1590344635,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6Mzc0MjU3NzE1"},"nonce":"+LlkRa0NpzdKrHU9GusxBLmmdkY=","target":"5b5f941b0b063d761b734c6c482a20d213eb1505610a087c4083d890628a1706","message":"There is an unmaintained fork, which supports better seeding lengths, esp for 64bit or even 128 and 256bits. But it's a lot of work to include that. See #31 . The longer the seed the better security.\nBut this is only for the length. \n\nHashes which are self-seeded automatically, eg google's farmhash using internal pointers as seed, abusing ASLR or such are not well supported.\nThere I just skip the seed tests, by using 0 as verification value. It's a good strategy still.\n\n100.000 cycles to change the seed is pretty crazy. It isn't counted in the tests, but timeouts should not happen. smhasher sets the seeds at once. Do you need to process the IV after each seed change that expensively?  There are a few hashes which need that, see the special cases in `Hash_init()`\nEsp. some crypto hashes.\n\nCan you push your interim state to your fork?","files":null},{"type":5,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1590344656,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDMzNjgxODI1ODM="},"nonce":"qbpACb47CTvNhL+SxI27pNxOOEE=","added":["enhancement"],"removed":[]}]}