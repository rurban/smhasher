{"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"ops":[{"type":4,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1597648558,"metadata":{"github-id":"MDEzOlJlb3BlbmVkRXZlbnQzNjYwNTEzNzQx"},"nonce":"J1rlbBYRkKx55DenVq8wq/jzsQs=","status":1},{"type":3,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1597648585,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY3NDcwNzY5MA==","github-url":"https://github.com/rurban/smhasher/issues/117#issuecomment-674707690"},"nonce":"JYnOhO/V0/mN1ctDqcRdv07gRI8=","message":"Documentation of UB problems still missing.\nAdding it now...","files":null},{"type":6,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1597648602,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdElzc3VlQ29tbWVudEVkaXQ6MzkzNDc4NDQx"},"nonce":"6lW25XG7XHuLQd1CxaFe71x4VVQ=","target":"153f6c0ceb6f314b40a750209435e82ce387f8bfba1f4c582e1c7f7558c8b9f8","message":"Documentation of UB problems still missing.\nAdding it now...\n\nTypical undefined behaviour (**UB**) problems:\n\n* Misaligned\n\n  Many fast word hashes dont check the input buffer for proper word\n  alignment, which will fail with ubsan or Sparc. word being `int32_t` or\n  `int64_t` or even more.\n  On some old RISC hardware this will be a BUS error, you can even let\n  Intel HW generate such a bus error by setting some CPU flag. But generally\n  using misaligned accesses is fine.\n  E.g. mx3, Spooky, mirhash, MUM, fasthash, Murmur3*, Murmur2*, metrohash,\n  Crap8, discohash, beamsplitter, lookup3, fletcher4, fletcher2, FNV2, \n  all sanmayce FNV1a\\_ variants (FNV1a\\_YT, FNV1A\\_Pippip\\_Yurii, FNV1A\\_Totenschiff, ...),\n  fibonacci\n\n  The usual mitigation is to check the buffer alignment either in the caller,\n  provide a pre-processing loop for the misaligned prefix, or copy the whole buffer\n  into a fresh aligned area.\n\n* oob - Out of bounds\n\n  Some hash function assume a padded input buffer which can be\n  accessed past its length up to the word size. This allows for faster\n  loop processing, as no 2nd loop or switch table for the rest is\n  needed, but it requires a cooperative calling enviroment and is as\n  such considered cheating.\n\n* Signed integer overflow\n\n  A simple type error, this hash needs to use unsigned integer types internally, to avoid\n  undefined and inconsistent behaviour.\n  i.e. SuperFastHash: signed integer overflow: -2147483641 + -113 cannot be represented in type 'int'\n\n* shift exponent overflow\n\n  With: FNV1A\\_Pippip\\_Yurii, FNV1A_Totenschiff, pair\\_multiply\\_shift, sumhash32\n  shift exponent 64 is too large for 64-bit type 'long unsigned int'","files":null},{"type":3,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1597650825,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDY3NDcyMzMzOQ==","github-url":"https://github.com/rurban/smhasher/issues/117#issuecomment-674723339"},"nonce":"FtNzg8//Ssdo7fZjyevg3fO9pCU=","message":"Done with 5ec69d6ed9b760c02b1f1f635234ba3f7113dd30","files":null},{"type":4,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1597650825,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MzY2MDY0MDAxOA=="},"nonce":"5RbuJows00KCtct2SaJUifbg6H8=","status":2}]}