{"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"ops":[{"type":1,"author":{"id":"ea8195bf30d85b36cadb8f08e79aa22a50e04d9a05d6d973c74da1c9f099555e"},"timestamp":1573641196,"metadata":{"github-id":"MDU6SXNzdWU1MjIxMTE2Mjc=","github-url":"https://github.com/rurban/smhasher/issues/82","origin":"github"},"nonce":"PpaJ9d06NvYiwN5rtqTG46zfuFY=","title":"Better Hashmap tests","message":"Originally I also checked various other much faster linear probing hashmaps, such as e.g. from rigtorp or the two swisstable variants (Google and Facebook), but I settled with the slow standard (seperate chaining) for fair comparison purposes.\nMaybe add other ones, and document them.\n\n@dumblob Speaking about currently worldwide available hashmaps, definitely skim the comparison from Martin Ankerl https://martin.ankerl.com/2019/04/01/hashmap-benchmarks-05-conclusion/ to notice one very important thing. Namely that some hashmaps are almost not at all sensitive to collisions and throughput and latency (Throughput versus latency) of the hash function, but other hashmaps rely completely on the quality and throughput and/or latency of the hash function.\nTo be fair in showing real use case scenarios, we would actually need to test one representative from the sensitive corner and one from the insensitive corner.\n\n@rurban True. There should be a linear probing one also, besides the usual insensitive std chaining.\nAnd we need to add the stddev to the mean cycles. I'll also add the initial insert/delete timings, but without trials and outlier removal.\n\nTaken from the discussion at https://github.com/rurban/smhasher/pull/80","files":null}]}